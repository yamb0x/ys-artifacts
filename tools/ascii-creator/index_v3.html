<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vid-to-ASCII - YS Studio Artifacts</title>
    <link rel="stylesheet" href="../../shared/preset-ui.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* Font Imports */
        @font-face {
            font-family: 'Courier Prime';
            src: url('../../fonts/Courier_Prime/CourierPrime-Regular.ttf') format('truetype');
            font-weight: 400;
        }

        @font-face {
            font-family: 'Courier Prime';
            src: url('../../fonts/Courier_Prime/CourierPrime-Bold.ttf') format('truetype');
            font-weight: 700;
        }

        @font-face {
            font-family: 'Basis Grotesque';
            src: url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.woff2') format('woff2'),
                 url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.woff') format('woff'),
                 url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kalice';
            src: url('../../fonts/Kalice/Kalice-Regular-alternative.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kalice';
            src: url('../../fonts/Kalice/Kalice-Italic-alternative.otf') format('opentype');
            font-weight: 400;
            font-style: italic;
            font-display: swap;
        }

        /* YS Studio Design System Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Colors */
            --ys-white: #FFFFFF;
            --ys-black: #000000;
            --ys-red: #FF0000;
            --ys-gray: #D9D9D9;
            --ys-blue: #0066FF;
            --ys-green: #00FF00;

            /* Fonts */
            --font-suisse: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-sangbleu: Georgia, 'Times New Roman', serif;
            --font-mono: 'Courier Prime', 'Courier New', monospace;

            /* Spacing */
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 24px;
            --spacing-lg: 40px;
            --spacing-xl: 80px;
        }

        body {
            font-family: var(--font-suisse);
            color: var(--ys-black);
            background: var(--ys-white);
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header Component */
        .ys-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 57px;
            padding: 24px;
            background: var(--ys-white);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 1000;
            border-bottom: 1px solid var(--ys-black);
        }

        .header-left {
            display: flex;
            gap: 2px;
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            color: var(--ys-black);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }

        .header-left:hover {
            opacity: 0.7;
        }

        .studio-name {
            font-weight: 300;
        }

        .project-type {
            font-style: italic;
        }

        .header-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            font-weight: 300;
        }

        .header-right {
            display: flex;
            gap: 40px;
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            font-weight: 300;
        }

        .header-right a {
            color: var(--ys-black);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }

        .header-right a:hover {
            opacity: 0.6;
        }

        .header-right a.active {
            font-weight: 500;
        }

        /* Cross Elements */
        .cross-small {
            width: 12px;
            height: 12px;
            position: relative;
            color: var(--ys-black);
            display: inline-block;
        }

        .cross-small::before,
        .cross-small::after {
            content: '';
            position: absolute;
            background: currentColor;
        }

        .cross-small::before {
            width: 1px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .cross-small::after {
            width: 100%;
            height: 1px;
            top: 50%;
            transform: translateY(-50%);
        }

        .cross-large {
            width: 40px;
            height: 40px;
            position: relative;
            color: var(--ys-red);
            display: inline-block;
        }

        .cross-large::before,
        .cross-large::after {
            content: '';
            position: absolute;
            background: currentColor;
        }

        .cross-large::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .cross-large::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Main Container */
        .ys-container {
            width: 100%;
            max-width: 1920px;
            margin: 0 auto;
            padding: 80px 24px 24px;
            min-height: 100vh;
        }

        /* Title Section */
        .title-section {
            margin-bottom: 20px;
            position: relative;
        }

        .type-display-xl {
            font-family: var(--font-sangbleu);
            font-size: 120px;
            line-height: 120px;
            letter-spacing: -4.8px;
            font-style: italic;
            text-transform: lowercase;
            font-weight: 400;
            margin: 20px 0;
        }

        /* Cross Wrapper Component */
        .ys-cross-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            width: 100%;
            background: var(--ys-white);
            margin-bottom: 24px;
        }

        .cross-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: 12px;
            position: relative;
        }

        .wrapper-content {
            flex: 1;
            padding: 16px;
        }

        .control-panel .wrapper-content {
            padding: 12px;
        }

        /* Main Working Area - Side by Side */
        .main-workspace {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            margin-bottom: 24px;
            align-items: start;
        }

        /* Left Panel - Controls */
        .control-panel {
            position: sticky;
            top: 80px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            padding-right: 8px;
        }

        /* Custom Scrollbar for Control Panel */
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: var(--ys-white);
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: var(--ys-black);
            border-radius: 0;
        }

        /* Right Panel - ASCII Output */
        .output-panel {
            min-height: 400px;
        }

        /* Video Processing Indicator */
        #videoProcessing {
            display: none;
            padding: 40px;
            text-align: center;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            margin-bottom: 24px;
        }

        .processing-text {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .processing-bar {
            width: 100%;
            height: 2px;
            background: var(--ys-gray);
            position: relative;
        }

        .processing-bar-fill {
            height: 100%;
            background: var(--ys-black);
            width: 0%;
            transition: width 0.3s;
        }

        /* Video Keyframe Grid */
        #videoKeyframeSection {
            display: none;
            margin-bottom: 24px;
        }

        .video-header {
            padding: 16px;
            border-bottom: 1px solid var(--ys-black);
        }

        .video-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .video-meta {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .video-meta-item {
            display: flex;
            gap: 6px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .video-meta-label {
            color: #666;
        }

        .video-meta-value {
            color: var(--ys-black);
        }

        .playback-controls {
            padding: 12px 16px;
            border-bottom: 1px solid var(--ys-black);
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--ys-white);
        }

        .playback-btn {
            background: var(--ys-white);
            color: var(--ys-black);
            border: 1px solid var(--ys-black);
            padding: 8px 16px;
            font-family: var(--font-suisse);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }

        .playback-btn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .playback-btn.playing {
            background: var(--ys-red);
            color: var(--ys-white);
            border-color: var(--ys-red);
        }

        .fps-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fps-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            min-width: 50px;
            color: #666;
        }

        .fps-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 1px;
            background: var(--ys-black);
            outline: none;
            cursor: pointer;
        }

        .fps-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
        }

        .fps-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
            border: none;
        }

        .export-all-btn {
            background: var(--ys-black);
            color: var(--ys-white);
            border: none;
            padding: 6px 12px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .export-all-btn:hover {
            opacity: 0.8;
        }

        .export-all-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }


        .keyframe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
            padding: 12px;
        }

        .keyframe-card {
            border: 1px solid var(--ys-black);
            cursor: pointer;
            transition: all 0.2s;
            background: var(--ys-white);
        }

        .keyframe-card:hover {
            transform: scale(1.02);
        }

        .keyframe-card.selected {
            border-width: 2px;
            border-color: var(--ys-red);
        }

        .keyframe-thumbnail {
            width: 100%;
            aspect-ratio: 16 / 9;
            object-fit: cover;
            display: block;
            border-bottom: 1px solid var(--ys-black);
            image-rendering: crisp-edges;
        }

        .keyframe-info {
            padding: 6px;
        }

        .keyframe-timestamp {
            font-size: 10px;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .keyframe-frame-num {
            font-size: 8px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 4px;
        }

        .keyframe-export-btn {
            width: 100%;
            padding: 4px;
            margin-top: 4px;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .keyframe-export-btn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        /* Upload Area */
        .upload-section {
            margin-bottom: 16px;
        }

        .upload-area {
            border: 1px solid var(--ys-black);
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            background: var(--ys-white);
        }

        .upload-area:hover {
            background: var(--ys-gray);
        }

        .upload-area.dragover {
            background: var(--ys-gray);
        }

        .upload-area.has-image {
            padding: 15px;
            cursor: default;
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 8px;
            display: block;
        }

        .preview-container {
            position: relative;
            width: 100%;
        }

        .preview-img {
            width: 100%;
            height: auto;
            display: block;
            border: 1px solid var(--ys-black);
        }

        .replace-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--ys-white);
            border: 1px solid var(--ys-black);
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .replace-btn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        /* Controls */
        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-item label {
            font-size: 10px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            font-weight: 400;
            line-height: 1.2;
        }

        .control-item input,
        .control-item select {
            padding: 6px;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            font-family: var(--font-suisse);
            font-size: 12px;
        }

        .control-item input[type="color"] {
            height: 32px;
            cursor: pointer;
            width: 100%;
        }

        /* Custom Range Slider Styling */
        .control-item input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 1px;
            background: var(--ys-black);
            outline: none;
            cursor: pointer;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
            border: none;
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
            border: none;
        }

        .control-item input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 1px;
            cursor: pointer;
            background: var(--ys-black);
        }

        .control-item input[type="range"]::-moz-range-track {
            width: 100%;
            height: 1px;
            cursor: pointer;
            background: var(--ys-black);
        }


        /* ASCII Output */
        .ascii-output {
            font-family: var(--font-mono);
            white-space: pre;
            overflow: auto;
            padding: 24px;
            background: var(--ys-white);
            border: 1px solid var(--ys-black);
            font-size: 12px;
            line-height: 1;
            min-height: 200px;
            font-weight: 400;
            text-align: center;
            display: block;
        }

        .ascii-output-inner {
            display: inline-block;
            text-align: left;
        }

        .ascii-output.bold {
            font-weight: 700;
        }

        /* Export Section - Inline with Output */
        .export-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .export-btn {
            padding: 10px 16px;
            background: var(--ys-white);
            border: 1px solid var(--ys-black);
            font-family: var(--font-suisse);
            font-size: 11px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-btn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .export-btn.red {
            border-color: var(--ys-red);
            color: var(--ys-red);
        }

        .export-btn.red:hover {
            background: var(--ys-red);
            color: var(--ys-white);
        }

        /* Hidden elements */
        #fileInput {
            display: none;
        }

        #canvas {
            display: none;
        }

        /* Info Text */
        .info-text {
            font-size: 11px;
            line-height: 14px;
            color: var(--ys-black);
            text-align: center;
            margin: 2px 0;
        }

        /* Range Value Display */
        .range-value {
            font-size: 10px;
            color: var(--ys-black);
            margin-left: 4px;
        }

        /* Animation Controls */
        #animPlayBtn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        #animPlayBtn.playing {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        #animResetBtn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .anim-format-toggle:hover:not(.active) {
            background: var(--ys-gray);
        }

        #exportAnimationBtn:hover {
            background: var(--ys-white);
            color: var(--ys-black);
        }

        /* Recording pulse animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #animRecordingDot {
            animation: pulse 1s infinite;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-workspace {
                grid-template-columns: 1fr;
            }

            .control-panel {
                position: static;
                max-height: none;
            }

            .type-display-xl {
                font-size: 60px;
                line-height: 60px;
            }
        }

        @media (max-width: 768px) {
            .export-row {
                grid-template-columns: 1fr;
            }

            .color-presets {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="ys-header">
        <a href="/" class="header-left">
            <span class="studio-name">YAMBO STUDIO</span>
            <span>—</span>
            <span class="project-type">Artifacts</span>
        </a>
        <div class="header-center">vid-to-ASCII</div>
        <nav class="header-right">
            <a href="/about.html">About</a>
            <a href="/">Tools</a>
        </nav>
    </header>

    <!-- Main Container -->
    <div class="ys-container">
        <!-- Title Section -->
        <div class="title-section">
            <h1 class="type-display-xl">ascii interpreter</h1>
        </div>

        <!-- Main Workspace -->
        <div class="main-workspace">
            <!-- Left Panel - Controls -->
            <div class="control-panel">
                <!-- Upload Section -->
                <div class="ys-cross-wrapper upload-section">
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                    <div class="wrapper-content">
                        <div class="upload-area" id="uploadArea">
                            <span class="upload-icon">⊕</span>
                            <p class="info-text">Drop image or click to select</p>
                            <p class="info-text" style="font-size: 10px;">PNG, JPG, GIF, WebP</p>
                        </div>
                        <div class="preview-container" id="previewContainer" style="display: none;">
                            <img id="previewImage" class="preview-img">
                            <button class="replace-btn" id="replaceBtn" onclick="replaceMedia()">Replace</button>
                        </div>
                        <input type="file" id="fileInput" accept="image/*,video/mp4,video/webm">
                    </div>
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                </div>

                <!-- Preset Section -->
                <div id="presetContainer"></div>

                <!-- Video Settings Section -->
                <div class="ys-cross-wrapper" id="videoSettingsSection">
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                    <div class="wrapper-content">
                        <div class="controls-section">
                            <!-- Keyframe Count Selection -->
                            <div class="control-item">
                                <label>Keyframe Count</label>
                                <select id="keyframeCount">
                                    <option value="5">5 frames (fast)</option>
                                    <option value="10" selected>10 frames (balanced)</option>
                                    <option value="15">15 frames (detailed)</option>
                                    <option value="20">20 frames (very detailed)</option>
                                </select>
                            </div>

                            <!-- Extraction Range Presets -->
                            <div class="control-item">
                                <label>Extraction Range</label>
                                <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                                    <button class="range-preset-btn active" data-range="full"
                                            style="flex: 1; padding: 6px; border: 1px solid var(--ys-black); background: var(--ys-black); color: var(--ys-white); font-size: 9px; text-transform: uppercase; cursor: pointer; transition: all 0.2s;">
                                        Full
                                    </button>
                                    <button class="range-preset-btn" data-range="start"
                                            style="flex: 1; padding: 6px; border: 1px solid var(--ys-black); background: var(--ys-white); color: var(--ys-black); font-size: 9px; text-transform: uppercase; cursor: pointer; transition: all 0.2s;">
                                        Start
                                    </button>
                                    <button class="range-preset-btn" data-range="middle"
                                            style="flex: 1; padding: 6px; border: 1px solid var(--ys-black); background: var(--ys-white); color: var(--ys-black); font-size: 9px; text-transform: uppercase; cursor: pointer; transition: all 0.2s;">
                                        Middle
                                    </button>
                                    <button class="range-preset-btn" data-range="end"
                                            style="flex: 1; padding: 6px; border: 1px solid var(--ys-black); background: var(--ys-white); color: var(--ys-black); font-size: 9px; text-transform: uppercase; cursor: pointer; transition: all 0.2s;">
                                        End
                                    </button>
                                </div>
                            </div>

                            <!-- Custom Time Range -->
                            <div class="control-item" id="customRangeControls" style="display: none;">
                                <label>Start Time <span class="range-value" id="startTimeValue">0.0s</span></label>
                                <input type="range" id="startTime" min="0" max="30" step="0.5" value="0">

                                <label style="margin-top: 8px;">Duration <span class="range-value" id="durationValue">Full</span></label>
                                <input type="range" id="duration" min="1" max="30" step="0.5" value="30">
                            </div>

                            <div style="font-size: 9px; opacity: 0.7; margin-top: 8px; line-height: 1.4;">
                                <strong>Full:</strong> Entire video | <strong>Start:</strong> First 5s | <strong>Middle:</strong> Center 5s | <strong>End:</strong> Last 5s
                            </div>
                        </div>
                    </div>
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                </div>

                <!-- Controls -->
                <div class="ys-cross-wrapper">
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                    <div class="wrapper-content">
                        <div class="controls-section">
                            <!-- Character Set -->
                            <div class="control-item">
                                <label>Character Set</label>
                                <select id="charSet">
                                    <option value="standard">Standard</option>
                                    <option value="simple">Simple</option>
                                    <option value="blocks">Blocks</option>
                                    <option value="extended">Extended</option>
                                    <option value="binary">Binary (0/1)</option>
                                    <option value="custom">Custom</option>
                                </select>
                            </div>

                            <!-- Custom Characters -->
                            <div class="control-item">
                                <label>Custom Characters</label>
                                <input type="text" id="customChars" placeholder=" .:-=+*#%@" disabled>
                            </div>

                            <!-- Width Control (only for image mode) -->
                            <div class="control-item" id="widthControl">
                                <label>Width <span class="range-value" id="widthValue">100</span></label>
                                <input type="range" id="width" value="100" min="40" max="200" step="10">
                            </div>

                            <!-- Font Size -->
                            <div class="control-item">
                                <label><span id="fontSizeLabel">Font Size</span> <span class="range-value" id="fontSizeValue">12px</span></label>
                                <input type="range" id="fontSize" value="12" min="5" max="24" step="1">
                                <div class="control-hint" id="fontSizeHint" style="display: none; font-size: 9px; opacity: 0.7; margin-top: 4px;">Smaller = more detail, Larger = blockier</div>
                            </div>

                            <!-- Letter Spacing -->
                            <div class="control-item">
                                <label>Letter Spacing <span class="range-value" id="letterSpacingValue">0px</span></label>
                                <input type="range" id="letterSpacing" value="0" min="-2" max="8" step="0.5">
                            </div>

                            <!-- Line Height -->
                            <div class="control-item">
                                <label>Line Height <span class="range-value" id="lineHeightValue">1.0</span></label>
                                <input type="range" id="lineHeight" value="1" min="0.5" max="2" step="0.1">
                            </div>

                            <!-- Font Weight -->
                            <div class="control-item">
                                <label>Font Weight</label>
                                <select id="fontWeight">
                                    <option value="normal">Normal</option>
                                    <option value="bold">Bold</option>
                                </select>
                            </div>

                            <!-- Algorithm -->
                            <div class="control-item">
                                <label>Algorithm</label>
                                <select id="algorithm">
                                    <option value="average">Average</option>
                                    <option value="luminosity">Luminosity</option>
                                    <option value="lightness">Lightness</option>
                                    <option value="value">Value (HSV)</option>
                                    <option value="luma">Luma (BT.709)</option>
                                </select>
                            </div>

                            <!-- Invert -->
                            <div class="control-item">
                                <label>Invert</label>
                                <select id="invert">
                                    <option value="false">Normal</option>
                                    <option value="true">Inverted</option>
                                </select>
                            </div>

                            <!-- Color Mode -->
                            <div class="control-item">
                                <label>Color Mode</label>
                                <select id="colorMode">
                                    <option value="mono">Monochrome</option>
                                    <option value="html">Original Colors</option>
                                    <option value="duotone">Duotone</option>
                                    <option value="gradient">Gradient Map</option>
                                    <option value="matrix">Matrix Rain</option>
                                    <option value="retro">Retro Terminal</option>
                                    <option value="cyberpunk">Cyberpunk</option>
                                </select>
                            </div>

                            <!-- Text Color -->
                            <div class="control-item">
                                <label>Text Color</label>
                                <input type="color" id="textColor" value="#000000">
                            </div>

                            <!-- Background Color -->
                            <div class="control-item">
                                <label>Background Color</label>
                                <input type="color" id="bgColor" value="#FFFFFF">
                            </div>

                            <!-- Color Correction (for Original Colors mode) -->
                            <div class="control-item" id="colorCorrectionSection" style="display: none;">
                                <label>Color Correction</label>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Exposure <span class="range-value" id="exposureValue">1.0</span></label>
                                    <input type="range" id="exposure" value="1" min="0.1" max="3.0" step="0.1">
                                </div>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Contrast <span class="range-value" id="contrastValue">1.0</span></label>
                                    <input type="range" id="contrast" value="1" min="0" max="5" step="0.1">
                                </div>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Saturation <span class="range-value" id="saturationValue">1.0</span></label>
                                    <input type="range" id="saturation" value="1" min="0" max="5" step="0.1">
                                </div>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Vibrance <span class="range-value" id="vibranceValue">0</span></label>
                                    <input type="range" id="vibrance" value="0" min="-1" max="2" step="0.1">
                                </div>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Hue Shift <span class="range-value" id="hueShiftValue">0°</span></label>
                                    <input type="range" id="hueShift" value="0" min="-180" max="180" step="5">
                                </div>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Gamma <span class="range-value" id="gammaValue">1.0</span></label>
                                    <input type="range" id="gamma" value="1" min="0.1" max="3.0" step="0.1">
                                </div>

                                <div style="margin-top: 8px;">
                                    <label style="font-size: 9px;">Brightness <span class="range-value" id="brightnessValue">0</span></label>
                                    <input type="range" id="brightness" value="0" min="-100" max="100" step="5">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Output -->
            <div class="output-panel">
                <!-- Video Processing Indicator -->
                <div id="videoProcessing">
                    <div class="processing-text">Loading video...</div>
                    <div class="processing-bar">
                        <div class="processing-bar-fill" id="processingBarFill"></div>
                    </div>
                </div>

                <!-- Video Keyframe Grid -->
                <div id="videoKeyframeSection" class="ys-cross-wrapper">
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>

                    <!-- Video Header with Info -->
                    <div class="video-header">
                        <div class="video-title" id="keyframeGridTitle">VIDEO KEYFRAMES (10 frames)</div>
                        <div class="video-meta">
                            <div class="video-meta-item">
                                <span class="video-meta-label">Video:</span>
                                <span class="video-meta-value" id="videoResolution">1920×1080px</span>
                            </div>
                            <div class="video-meta-item">
                                <span class="video-meta-label">ASCII Grid:</span>
                                <span class="video-meta-value" id="asciiGridSize">192×108 chars</span>
                            </div>
                            <div class="video-meta-item">
                                <span class="video-meta-label">Density:</span>
                                <span class="video-meta-value" id="densityInfo">10×10px/char</span>
                            </div>
                        </div>
                    </div>

                    <!-- Playback Controls -->
                    <div class="playback-controls">
                        <button class="playback-btn" onclick="toggleKeyframePlayback()" id="playbackBtn">
                            ▶ Play
                        </button>
                        <div class="fps-control">
                            <label class="fps-label" id="fpsLabel">10 FPS</label>
                            <input type="range" class="fps-slider" id="fpsSlider"
                                   min="1" max="30" value="10" step="1"
                                   oninput="updatePlaybackFPS(parseInt(this.value))">
                        </div>
                    </div>

                    <!-- Keyframe Grid -->
                    <div class="keyframe-grid" id="keyframeGrid">
                        <!-- Keyframe cards will be dynamically inserted here -->
                    </div>

                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                </div>

                <div class="ys-cross-wrapper">
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                    <div class="wrapper-content">
                        <div id="asciiOutputWrapper" style="display: inline-block;">
                            <pre id="asciiOutput" class="ascii-output"><span class="ascii-output-inner">// ascii interpreter
// waiting for image input...
// drop or select an image to begin</span></pre>
                        </div>

                        <!-- Export Buttons -->
                        <div class="export-row">
                            <button class="export-btn" onclick="exportText()">Export TXT</button>
                            <button class="export-btn" onclick="exportHTML()">Export HTML</button>
                            <button class="export-btn" onclick="exportPNG()">Export PNG</button>
                            <button class="export-btn" id="exportAllZipBtn" onclick="exportAllKeyframes()" style="display: none;">Export All (ZIP)</button>
                            <button class="export-btn" onclick="copyToClipboard()">Copy</button>
                            <button class="export-btn" onclick="resetAll()">Reset</button>
                        </div>
                    </div>
                    <div class="cross-row">
                        <span class="cross-small"></span>
                        <span class="cross-small"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Canvas -->
    <canvas id="canvas"></canvas>

    <script>
        // Update date
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        // Date display removed - navigation bar is now consistent across all pages

        // Character sets
        const charSets = {
            standard: ' .:-=+*#%@',
            simple: ' .oO0@',
            blocks: ' ░▒▓█',
            extended: ' .\':,;^`"~-_+=<>iv%xclrs{*}I?!][1)|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao#MW&8B@$',
            binary: ' 01',
            custom: ''
        };

        let currentImage = null;
        let currentAsciiData = '';
        let currentColorData = null;  // Store color data for animation

        // Video state
        let currentVideo = null;
        let videoKeyframes = [];
        let selectedKeyframeIndex = 0;
        let isVideoMode = false;

        // Playback state
        let isPlayingKeyframes = false;
        let playbackInterval = null;
        let playbackFPS = 10; // Frames per second for playback

        // File input handling
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const previewContainer = document.getElementById('previewContainer');
        const previewImage = document.getElementById('previewImage');
        const asciiOutput = document.getElementById('asciiOutput');

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // Replace media function (works for both images and videos)
        function replaceMedia() {
            fileInput.click();
        }

        // Range input value displays
        document.getElementById('width').addEventListener('input', (e) => {
            document.getElementById('widthValue').textContent = e.target.value;
        });

        document.getElementById('fontSize').addEventListener('input', (e) => {
            document.getElementById('fontSizeValue').textContent = e.target.value + 'px';
        });

        document.getElementById('letterSpacing').addEventListener('input', (e) => {
            document.getElementById('letterSpacingValue').textContent = e.target.value + 'px';
        });

        document.getElementById('lineHeight').addEventListener('input', (e) => {
            document.getElementById('lineHeightValue').textContent = e.target.value;
        });

        // Color correction range inputs
        document.getElementById('exposure').addEventListener('input', (e) => {
            document.getElementById('exposureValue').textContent = e.target.value;
        });

        document.getElementById('contrast').addEventListener('input', (e) => {
            document.getElementById('contrastValue').textContent = e.target.value;
        });

        document.getElementById('saturation').addEventListener('input', (e) => {
            document.getElementById('saturationValue').textContent = e.target.value;
        });

        document.getElementById('vibrance').addEventListener('input', (e) => {
            document.getElementById('vibranceValue').textContent = e.target.value;
        });

        document.getElementById('hueShift').addEventListener('input', (e) => {
            document.getElementById('hueShiftValue').textContent = e.target.value + '°';
        });

        document.getElementById('gamma').addEventListener('input', (e) => {
            document.getElementById('gammaValue').textContent = e.target.value;
        });

        document.getElementById('brightness').addEventListener('input', (e) => {
            document.getElementById('brightnessValue').textContent = e.target.value;
        });

        // Show/hide color correction section based on color mode
        document.getElementById('colorMode').addEventListener('change', (e) => {
            const colorCorrectionSection = document.getElementById('colorCorrectionSection');
            if (e.target.value === 'html') {
                colorCorrectionSection.style.display = 'block';
            } else {
                colorCorrectionSection.style.display = 'none';
            }
        });

        // Control listeners
        document.getElementById('charSet').addEventListener('change', () => {
            const customInput = document.getElementById('customChars');
            if (document.getElementById('charSet').value === 'custom') {
                customInput.disabled = false;
                customInput.focus();
            } else {
                customInput.disabled = true;
            }
            if (currentImage) processImage();
        });

        // Range preset button handlers
        document.querySelectorAll('.range-preset-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // Update button states
                document.querySelectorAll('.range-preset-btn').forEach(b => {
                    b.classList.remove('active');
                    b.style.background = 'var(--ys-white)';
                    b.style.color = 'var(--ys-black)';
                });
                this.classList.add('active');
                this.style.background = 'var(--ys-black)';
                this.style.color = 'var(--ys-white)';
            });
        });

        // Add listeners for all controls
        ['width', 'algorithm', 'colorMode', 'textColor', 'bgColor', 'invert',
         'fontSize', 'fontWeight', 'letterSpacing', 'lineHeight', 'customChars',
         'exposure', 'contrast', 'saturation', 'vibrance', 'hueShift', 'gamma', 'brightness'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => {
                    if (currentImage) {
                        processImage();
                    } else if (isVideoMode && videoKeyframes.length > 0) {
                        // Update video info bar if font settings changed (affects density)
                        if (id === 'fontSize' || id === 'letterSpacing' || id === 'lineHeight') {
                            updateVideoInfo();
                        }
                        // Update current frame display with new settings in real-time
                        displayKeyframeASCII(videoKeyframes[selectedKeyframeIndex]);
                    }
                });
                if (element.type === 'range') {
                    element.addEventListener('input', () => {
                        if (currentImage) {
                            processImage();
                        } else if (isVideoMode && videoKeyframes.length > 0) {
                            // Update video info bar if font settings changed (affects density)
                            if (id === 'fontSize' || id === 'letterSpacing' || id === 'lineHeight') {
                                updateVideoInfo();
                            }
                            // Update current frame display with new settings in real-time
                            displayKeyframeASCII(videoKeyframes[selectedKeyframeIndex]);
                        }
                    });
                }
            }
        });

        // File type router
        function handleFile(file) {
            if (file.type.startsWith('image/')) {
                isVideoMode = false;
                updateUIForImageMode();
                handleImage(file);
            } else if (file.type.startsWith('video/')) {
                isVideoMode = true;
                updateUIForVideoMode();
                handleVideo(file);
            } else {
                alert('Unsupported file type. Please upload an image (PNG, JPG) or video (MP4, WebM).');
            }
        }

        // Update UI for image mode
        function updateUIForImageMode() {
            document.getElementById('widthControl').style.display = 'block';
            document.getElementById('fontSizeLabel').textContent = 'Font Size';
            document.getElementById('fontSizeHint').style.display = 'none';
            document.getElementById('exportAllZipBtn').style.display = 'none';
            document.getElementById('replaceBtn').textContent = 'Replace Image';
        }

        // Update UI for video mode
        function updateUIForVideoMode() {
            document.getElementById('widthControl').style.display = 'none';
            document.getElementById('fontSizeLabel').textContent = 'ASCII Density (Font Size)';
            document.getElementById('fontSizeHint').style.display = 'block';
            document.getElementById('exportAllZipBtn').style.display = 'inline-block';
            document.getElementById('replaceBtn').textContent = 'Replace Video';
        }

        function handleImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                currentImage = new Image();
                currentImage.onload = () => {
                    previewImage.src = currentImage.src;
                    uploadArea.style.display = 'none';
                    previewContainer.style.display = 'block';
                    hideVideoGrid();
                    processImage();
                };
                currentImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Calculate ASCII dimensions based on FIXED canvas size and font metrics
        function calculateASCIIDimensions(canvasWidth, canvasHeight) {
            // Get font parameters
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const letterSpacing = parseFloat(document.getElementById('letterSpacing').value);
            const lineHeight = parseFloat(document.getElementById('lineHeight').value);

            // Character dimensions in pixels
            // Monospace characters are approximately 0.6x as wide as they are tall
            const charAspectRatio = 0.6;
            const charWidth = (fontSize * charAspectRatio) + letterSpacing;
            const charHeight = fontSize * lineHeight;

            // Calculate how many characters FIT in the fixed canvas
            const asciiWidth = Math.floor(canvasWidth / charWidth);
            const asciiHeight = Math.floor(canvasHeight / charHeight);

            // Validate minimum dimensions
            if (asciiWidth < 10 || asciiHeight < 10) {
                console.warn('ASCII dimensions too small. Increase font size or reduce spacing.');
                return null;
            }

            return {
                asciiWidth,
                asciiHeight,
                charWidth,
                charHeight,
                canvasWidth,
                canvasHeight
            };
        }

        // Resample ImageData from source dimensions to target dimensions
        function resampleImageData(sourceImageData, sourceWidth, sourceHeight, targetWidth, targetHeight) {
            // Create temporary canvases for resampling
            const sourceCanvas = document.createElement('canvas');
            const targetCanvas = document.createElement('canvas');
            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');

            // Set up source canvas
            sourceCanvas.width = sourceWidth;
            sourceCanvas.height = sourceHeight;
            sourceCtx.putImageData(sourceImageData, 0, 0);

            // Set up target canvas
            targetCanvas.width = targetWidth;
            targetCanvas.height = targetHeight;

            // Draw source to target with resampling
            targetCtx.drawImage(sourceCanvas, 0, 0, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);

            // Get resampled ImageData
            return targetCtx.getImageData(0, 0, targetWidth, targetHeight);
        }

        async function handleVideo(file) {
            // Check file size (max 50MB)
            const maxSize = 50 * 1024 * 1024;
            if (file.size > maxSize) {
                alert('Video file is too large. Maximum size is 50MB.');
                return;
            }

            // Hide image preview, show video processing
            uploadArea.style.display = 'none';
            previewContainer.style.display = 'none';

            // Show processing indicator
            showVideoProcessing('Loading video...');

            try {
                // Load video
                currentVideo = document.createElement('video');
                currentVideo.preload = 'metadata';

                await new Promise((resolve, reject) => {
                    currentVideo.onloadedmetadata = resolve;
                    currentVideo.onerror = reject;
                    currentVideo.src = URL.createObjectURL(file);
                });

                // Check duration (max 30 seconds)
                if (currentVideo.duration > 30) {
                    alert('Video is too long. Maximum duration is 30 seconds.');
                    resetUpload();
                    return;
                }

                // Extract metadata
                const metadata = {
                    duration: currentVideo.duration,
                    width: currentVideo.videoWidth,
                    height: currentVideo.videoHeight,
                    fps: 30 // Default, hard to detect actual FPS
                };

                // Extract keyframes
                await extractKeyframes(metadata);

            } catch (error) {
                console.error('Video loading error:', error);
                alert('Failed to load video. Please try a different file.');
                resetUpload();
            }
        }

        async function extractKeyframes(metadata) {
            const keyframeCount = parseInt(document.getElementById('keyframeCount').value);

            // Get extraction range based on selected preset
            const activeBtn = document.querySelector('.range-preset-btn.active');
            const rangePreset = activeBtn ? activeBtn.dataset.range : 'full';
            const { startTime, duration } = calculateExtractionRange(metadata.duration, rangePreset);

            const interval = duration / (keyframeCount + 1);
            videoKeyframes = [];

            showVideoProcessing(`Extracting ${keyframeCount} frames...`);

            // Create offscreen canvas for frame extraction
            const extractionCanvas = document.createElement('canvas');
            const extractionCtx = extractionCanvas.getContext('2d');

            for (let i = 1; i <= keyframeCount; i++) {
                const timestamp = startTime + (i * interval);

                // Update progress
                const progress = Math.round((i / keyframeCount) * 100);
                showVideoProcessing(`Extracting frames... ${progress}%`);

                try {
                    // Seek to timestamp
                    await seekToTime(currentVideo, timestamp);

                    // ALWAYS extract at full video resolution
                    // This allows font settings to change later without re-extraction
                    extractionCanvas.width = currentVideo.videoWidth;
                    extractionCanvas.height = currentVideo.videoHeight;
                    extractionCtx.drawImage(currentVideo, 0, 0, currentVideo.videoWidth, currentVideo.videoHeight);

                    // Get FULL RESOLUTION ImageData for this frame
                    const fullResImageData = extractionCtx.getImageData(0, 0, currentVideo.videoWidth, currentVideo.videoHeight);

                    // Calculate ASCII dimensions with current font settings
                    const dimensions = calculateASCIIDimensions(
                        currentVideo.videoWidth,
                        currentVideo.videoHeight
                    );

                    if (!dimensions) {
                        alert('Font settings create too small ASCII grid. Please adjust font size, letter spacing, or line height.');
                        return;
                    }

                    // Resample to ASCII dimensions
                    const resampledImageData = resampleImageData(fullResImageData, currentVideo.videoWidth, currentVideo.videoHeight, dimensions.asciiWidth, dimensions.asciiHeight);

                    // Convert to ASCII (initial conversion)
                    const asciiResult = convertImageDataToASCII(resampledImageData);

                    // Create thumbnail
                    const thumbnail = extractionCanvas.toDataURL('image/jpeg', 0.7);

                    // Store keyframe WITH FULL RES imageData for re-processing with different settings
                    videoKeyframes.push({
                        index: i - 1,
                        timestamp: timestamp,
                        fullResImageData: fullResImageData, // Store FULL resolution for flexibility!
                        videoWidth: currentVideo.videoWidth,
                        videoHeight: currentVideo.videoHeight,
                        asciiData: asciiResult.ascii,
                        htmlAscii: asciiResult.htmlAscii,
                        colorData: asciiResult.colorData,
                        thumbnail: thumbnail,
                        frameNumber: Math.floor(timestamp * metadata.fps)
                    });

                } catch (error) {
                    console.error(`Failed to extract frame at ${timestamp}s:`, error);
                }
            }

            // Show keyframe grid
            hideVideoProcessing();
            displayKeyframeGrid();

            // Select first frame by default
            selectKeyframe(0);
        }

        function seekToTime(video, time) {
            return new Promise((resolve) => {
                video.onseeked = () => resolve();
                video.currentTime = time;
            });
        }

        // Calculate extraction range based on preset
        function calculateExtractionRange(videoDuration, preset) {
            const extractDuration = 5; // Fixed 5 seconds for start/middle/end presets

            switch(preset) {
                case 'start':
                    return {
                        startTime: 0,
                        duration: Math.min(extractDuration, videoDuration)
                    };

                case 'middle':
                    const middleStart = Math.max(0, (videoDuration / 2) - (extractDuration / 2));
                    return {
                        startTime: middleStart,
                        duration: Math.min(extractDuration, videoDuration)
                    };

                case 'end':
                    const endStart = Math.max(0, videoDuration - extractDuration);
                    return {
                        startTime: endStart,
                        duration: Math.min(extractDuration, videoDuration)
                    };

                case 'full':
                default:
                    return {
                        startTime: 0,
                        duration: videoDuration
                    };
            }
        }

        function convertImageDataToASCII(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const pixels = imageData.data;

            const charSetType = document.getElementById('charSet').value;
            const chars = charSetType === 'custom' ?
                document.getElementById('customChars').value || charSets.standard :
                charSets[charSetType];

            const algorithm = document.getElementById('algorithm').value;
            const colorMode = document.getElementById('colorMode').value;
            const invert = document.getElementById('invert').value === 'true';

            let ascii = '';
            let htmlAscii = '';
            let colorData = [];

            for (let y = 0; y < height; y++) {
                let rowColorData = [];
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    const a = pixels[i + 3];

                    let brightness = getBrightness(r, g, b, algorithm);
                    if (invert) brightness = 255 - brightness;

                    const charIndex = Math.floor((brightness / 255) * (chars.length - 1));
                    const char = chars[charIndex] || chars[0];

                    let color = null;
                    switch(colorMode) {
                        case 'html':
                            // Apply color correction if in Original Colors mode
                            // Get color correction values
                            const exposureVal = parseFloat(document.getElementById('exposure').value);
                            const contrastVal = parseFloat(document.getElementById('contrast').value);
                            const saturationVal = parseFloat(document.getElementById('saturation').value);
                            const vibranceVal = parseFloat(document.getElementById('vibrance').value);
                            const hueShiftVal = parseFloat(document.getElementById('hueShift').value);
                            const gammaVal = parseFloat(document.getElementById('gamma').value);
                            const brightnessVal = parseFloat(document.getElementById('brightness').value);

                            // Apply color corrections
                            const correctedColor = applyColorCorrection(r, g, b, exposureVal, contrastVal, saturationVal, vibranceVal, hueShiftVal, gammaVal, brightnessVal);

                            color = `rgb(${correctedColor.r},${correctedColor.g},${correctedColor.b})`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'duotone':
                            const mix = brightness / 255;
                            const textCol = hexToRgb(document.getElementById('textColor').value);
                            const bgCol = hexToRgb(document.getElementById('bgColor').value);
                            const mixedR = Math.floor(textCol.r * (1 - mix) + bgCol.r * mix);
                            const mixedG = Math.floor(textCol.g * (1 - mix) + bgCol.g * mix);
                            const mixedB = Math.floor(textCol.b * (1 - mix) + bgCol.b * mix);
                            color = `rgb(${mixedR},${mixedG},${mixedB})`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'gradient':
                            const gradPos = brightness / 255;
                            const col1 = hexToRgb(document.getElementById('textColor').value);
                            const col2 = hexToRgb(document.getElementById('bgColor').value);
                            const gradR = Math.floor(col1.r * (1 - gradPos) + col2.r * gradPos);
                            const gradG = Math.floor(col1.g * (1 - gradPos) + col2.g * gradPos);
                            const gradB = Math.floor(col1.b * (1 - gradPos) + col2.b * gradPos);
                            color = `rgb(${gradR},${gradG},${gradB})`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'matrix':
                            const greenShade = Math.floor(100 + brightness * 0.6);
                            color = `rgb(0,${greenShade},0)`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'retro':
                            const retroColors = ['#FFB700', '#FF6B6B', '#4ECDC4', '#95E77E'];
                            const retroIndex = Math.floor((brightness / 255) * retroColors.length);
                            color = retroColors[Math.min(retroIndex, retroColors.length - 1)];
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'cyberpunk':
                            const cyberColors = ['#F72585', '#B5179E', '#7209B7', '#560BAD', '#480CA8'];
                            const cyberIndex = Math.floor((brightness / 255) * cyberColors.length);
                            color = cyberColors[Math.min(cyberIndex, cyberColors.length - 1)];
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        default: // mono
                            ascii += char;
                            color = null;
                    }

                    rowColorData.push(color);
                }
                colorData.push(rowColorData);
                ascii += '\n';
                if (colorMode !== 'mono') htmlAscii += '<br>';
            }

            return { ascii, htmlAscii, colorData };
        }

        // Reset upload helper
        function resetUpload() {
            stopKeyframePlayback(); // Stop playback if active
            uploadArea.style.display = 'block';
            hideVideoProcessing();
            hideVideoGrid();
            currentVideo = null;
            videoKeyframes = [];
            isVideoMode = false;
            updateUIForImageMode(); // Reset UI to image mode
        }

        // Video UI Helper Functions
        function showVideoProcessing(message) {
            const processing = document.getElementById('videoProcessing');
            const textEl = processing.querySelector('.processing-text');
            textEl.textContent = message;
            processing.style.display = 'block';
        }

        function hideVideoProcessing() {
            document.getElementById('videoProcessing').style.display = 'none';
        }

        function hideVideoGrid() {
            stopKeyframePlayback(); // Stop playback when hiding grid
            document.getElementById('videoKeyframeSection').style.display = 'none';
        }

        // Update video info with current dimensions and density
        function updateVideoInfo() {
            if (!isVideoMode || videoKeyframes.length === 0) return;

            const frame = videoKeyframes[0];
            const dimensions = calculateASCIIDimensions(frame.videoWidth, frame.videoHeight);

            if (!dimensions) return;

            // Update values
            document.getElementById('videoResolution').textContent = `${frame.videoWidth}×${frame.videoHeight}px`;
            document.getElementById('asciiGridSize').textContent = `${dimensions.asciiWidth}×${dimensions.asciiHeight} chars`;
            document.getElementById('densityInfo').textContent = `${dimensions.charWidth.toFixed(1)}×${dimensions.charHeight.toFixed(1)}px/char`;
        }

        function displayKeyframeGrid() {
            const section = document.getElementById('videoKeyframeSection');
            const grid = document.getElementById('keyframeGrid');
            const title = document.getElementById('keyframeGridTitle');

            section.style.display = 'block';
            title.textContent = `VIDEO KEYFRAMES (${videoKeyframes.length} frames)`;

            // Update video info bar
            updateVideoInfo();

            // Clear existing cards
            grid.innerHTML = '';

            // Create cards for each keyframe
            videoKeyframes.forEach((frame, index) => {
                const card = document.createElement('div');
                card.className = 'keyframe-card';
                card.dataset.index = index;

                card.innerHTML = `
                    <img src="${frame.thumbnail}" alt="Frame ${index + 1}" class="keyframe-thumbnail">
                    <div class="keyframe-info">
                        <div class="keyframe-timestamp">${frame.timestamp.toFixed(2)}s</div>
                        <div class="keyframe-frame-num">Frame ${frame.frameNumber}</div>
                    </div>
                `;

                card.addEventListener('click', () => {
                    // Stop playback when manually selecting a frame
                    if (isPlayingKeyframes) {
                        stopKeyframePlayback();
                    }
                    selectKeyframe(index);
                });

                grid.appendChild(card);
            });
        }

        function selectKeyframe(index) {
            if (index < 0 || index >= videoKeyframes.length) return;

            selectedKeyframeIndex = index;
            const frame = videoKeyframes[index];

            // Update current ASCII data for export
            currentAsciiData = frame.asciiData;
            currentColorData = frame.colorData;

            // Update visual selection
            document.querySelectorAll('.keyframe-card').forEach((card, i) => {
                if (i === index) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });

            // Display ASCII in main output
            displayKeyframeASCII(frame);

            // Update title to show current frame when playing
            if (isPlayingKeyframes) {
                const title = document.getElementById('keyframeGridTitle');
                title.textContent = `VIDEO KEYFRAMES (${videoKeyframes.length} frames) - Playing ${index + 1}/${videoKeyframes.length}`;
            }
        }

        function displayKeyframeASCII(frame) {
            const asciiOutput = document.getElementById('asciiOutput');
            const colorMode = document.getElementById('colorMode').value;

            // Calculate ASCII dimensions with CURRENT font settings
            const dimensions = calculateASCIIDimensions(frame.videoWidth, frame.videoHeight);

            if (!dimensions) {
                alert('Current font settings create too small ASCII grid. Please adjust font size, letter spacing, or line height.');
                return;
            }

            // Resample full-res image to current ASCII dimensions
            const resampledImageData = resampleImageData(
                frame.fullResImageData,
                frame.videoWidth,
                frame.videoHeight,
                dimensions.asciiWidth,
                dimensions.asciiHeight
            );

            // RE-CONVERT the resampled frame with current parameters!
            // This allows real-time parameter changes to work
            const asciiResult = convertImageDataToASCII(resampledImageData);

            // Update the frame's stored data (so exports use current settings)
            frame.asciiData = asciiResult.ascii;
            frame.htmlAscii = asciiResult.htmlAscii;
            frame.colorData = asciiResult.colorData;

            // Update currentAsciiData for exports
            currentAsciiData = asciiResult.ascii;
            currentColorData = asciiResult.colorData;

            // Apply styling
            const fontSize = document.getElementById('fontSize').value;
            const fontWeight = document.getElementById('fontWeight').value;
            const letterSpacing = document.getElementById('letterSpacing').value;
            const lineHeight = document.getElementById('lineHeight').value;
            const textColor = document.getElementById('textColor').value;
            const bgColor = document.getElementById('bgColor').value;

            asciiOutput.style.fontSize = fontSize + 'px';
            asciiOutput.style.fontWeight = fontWeight === 'bold' ? '700' : '400';
            asciiOutput.style.letterSpacing = letterSpacing + 'px';
            asciiOutput.style.lineHeight = lineHeight;

            // Auto-scale to fit viewport in video mode
            // Calculate the actual pixel dimensions the ASCII will take
            const estimatedWidth = dimensions.asciiWidth * dimensions.charWidth;
            const estimatedHeight = dimensions.asciiHeight * dimensions.charHeight;

            // Get available viewport space (rough estimate)
            const maxViewportWidth = window.innerWidth * 0.6; // Right panel is ~60% of window
            const maxViewportHeight = window.innerHeight * 0.8;

            // Calculate scale to fit
            const scaleX = maxViewportWidth / estimatedWidth;
            const scaleY = maxViewportHeight / estimatedHeight;
            const scale = Math.min(scaleX, scaleY, 1.0); // Never scale UP, only down

            // Apply scale transform
            if (scale < 1.0) {
                asciiOutput.style.transform = `scale(${scale})`;
                asciiOutput.style.transformOrigin = 'top left';

                // Pull up the content below by the amount we scaled down
                // This eliminates the gap without cropping
                requestAnimationFrame(() => {
                    const actualHeight = asciiOutput.scrollHeight;
                    const scaledHeight = actualHeight * scale;
                    const gapToRemove = actualHeight - scaledHeight;
                    asciiOutput.style.marginBottom = `-${gapToRemove}px`;
                });
            } else {
                asciiOutput.style.transform = 'none';
                asciiOutput.style.marginBottom = '0';
            }

            // Display based on color mode
            if (colorMode !== 'mono' && asciiResult.htmlAscii) {
                asciiOutput.innerHTML = `<span class="ascii-output-inner">${asciiResult.htmlAscii}</span>`;
            } else {
                asciiOutput.style.color = textColor;
                asciiOutput.innerHTML = `<span class="ascii-output-inner">${asciiResult.ascii.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>`;
            }

            // Set background
            if (colorMode === 'matrix') {
                asciiOutput.style.backgroundColor = '#0a0a0a';
            } else if (colorMode === 'retro') {
                asciiOutput.style.backgroundColor = '#1A1A2E';
            } else if (colorMode === 'cyberpunk') {
                asciiOutput.style.backgroundColor = '#0D0221';
            } else {
                asciiOutput.style.backgroundColor = bgColor;
            }
        }

        // Keyframe Playback Functions
        function toggleKeyframePlayback() {
            if (isPlayingKeyframes) {
                stopKeyframePlayback();
            } else {
                startKeyframePlayback();
            }
        }

        function startKeyframePlayback() {
            if (!videoKeyframes || videoKeyframes.length === 0) return;

            isPlayingKeyframes = true;
            const playbackBtn = document.getElementById('playbackBtn');
            playbackBtn.textContent = '⏸ Pause';
            playbackBtn.classList.add('playing');

            // Calculate frame delay based on FPS
            const frameDelay = 1000 / playbackFPS;

            // Start from current frame or beginning
            let currentFrame = selectedKeyframeIndex;

            playbackInterval = setInterval(() => {
                // Select and display next frame
                selectKeyframe(currentFrame);

                // Move to next frame
                currentFrame++;

                // Loop back to start when reaching the end
                if (currentFrame >= videoKeyframes.length) {
                    currentFrame = 0;
                }
            }, frameDelay);
        }

        function stopKeyframePlayback() {
            isPlayingKeyframes = false;
            const playbackBtn = document.getElementById('playbackBtn');
            playbackBtn.textContent = '▶ Play';
            playbackBtn.classList.remove('playing');

            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }

            // Reset title to default
            const title = document.getElementById('keyframeGridTitle');
            if (videoKeyframes.length > 0) {
                title.textContent = `VIDEO KEYFRAMES (${videoKeyframes.length} frames)`;
            }
        }

        function updatePlaybackFPS(fps) {
            playbackFPS = fps;
            document.getElementById('fpsLabel').textContent = `${fps} FPS`;
            document.getElementById('fpsSlider').value = fps;

            // If currently playing, restart with new FPS
            if (isPlayingKeyframes) {
                stopKeyframePlayback();
                startKeyframePlayback();
            }
        }

        // Export Functions for Video Keyframes
        async function exportAllKeyframes() {
            if (!videoKeyframes || videoKeyframes.length === 0) {
                alert('No keyframes to export');
                return;
            }

            const exportBtn = document.getElementById('exportAllZipBtn');
            exportBtn.disabled = true;
            exportBtn.textContent = 'Exporting...';

            try {
                const zip = new JSZip();
                const folder = zip.folder('video-keyframes');

                for (let i = 0; i < videoKeyframes.length; i++) {
                    const frame = videoKeyframes[i];
                    const timestamp = frame.timestamp.toFixed(1);
                    const paddedIndex = String(i + 1).padStart(2, '0');

                    // Add ASCII text file
                    folder.file(`frame_${paddedIndex}_${timestamp}s.txt`, frame.asciiData);

                    // Add PNG thumbnail
                    const thumbnailBlob = await dataURLtoBlob(frame.thumbnail);
                    folder.file(`frame_${paddedIndex}_${timestamp}s.png`, thumbnailBlob);

                    // Add HTML version if colored
                    if (frame.htmlAscii) {
                        const htmlContent = generateHTMLExport(frame);
                        folder.file(`frame_${paddedIndex}_${timestamp}s.html`, htmlContent);
                    }
                }

                // Generate and download ZIP
                const blob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `video-keyframes-${Date.now()}.zip`;
                link.click();
                URL.revokeObjectURL(link.href);

            } catch (error) {
                console.error('Export failed:', error);
                alert('Failed to export keyframes: ' + error.message);
            } finally {
                exportBtn.disabled = false;
                exportBtn.textContent = 'Export All (ZIP)';
            }
        }

        function dataURLtoBlob(dataURL) {
            return new Promise((resolve) => {
                fetch(dataURL)
                    .then(res => res.blob())
                    .then(blob => resolve(blob));
            });
        }

        function generateHTMLExport(frame) {
            const colorMode = document.getElementById('colorMode').value;
            const fontSize = document.getElementById('fontSize').value;
            const fontWeight = document.getElementById('fontWeight').value;
            const letterSpacing = document.getElementById('letterSpacing').value;
            const lineHeight = document.getElementById('lineHeight').value;
            const bgColor = document.getElementById('bgColor').value;

            const htmlContent = frame.htmlAscii || frame.asciiData.replace(/\n/g, '<br>');

            return `<!DOCTYPE html>
<html><head><title>ASCII Art Frame ${frame.timestamp.toFixed(1)}s - YS Studio</title>
<meta charset="UTF-8">
<style>
@font-face {
    font-family: 'Courier Prime';
    src: local('Courier Prime'), local('Courier New'), monospace;
}
body {
    margin: 0;
    padding: 20px;
    background: ${bgColor};
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}
pre {
    font-family: 'Courier Prime', monospace;
    font-size: ${fontSize}px;
    font-weight: ${fontWeight === 'bold' ? '700' : '400'};
    letter-spacing: ${letterSpacing}px;
    line-height: ${lineHeight};
    margin: 0;
    white-space: pre;
    display: inline-block;
}
</style></head>
<body><pre>${htmlContent}</pre></body></html>`;
        }

        function processImage() {
            if (!currentImage) return;

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            const width = parseInt(document.getElementById('width').value);
            const charSetType = document.getElementById('charSet').value;
            const chars = charSetType === 'custom' ?
                document.getElementById('customChars').value || charSets.standard :
                charSets[charSetType];

            const algorithm = document.getElementById('algorithm').value;
            const colorMode = document.getElementById('colorMode').value;
            const invert = document.getElementById('invert').value === 'true';

            // Calculate dimensions
            const charAspectRatio = 0.5;
            const scaleFactor = width / currentImage.width;
            const height = Math.floor(currentImage.height * scaleFactor * charAspectRatio);

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(currentImage, 0, 0, width, height);

            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            let ascii = '';
            let htmlAscii = '';
            let colorData = [];  // Store color information for animation

            for (let y = 0; y < height; y++) {
                let rowColorData = [];  // Store colors for this row
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    const a = pixels[i + 3];

                    let brightness = getBrightness(r, g, b, algorithm);
                    if (invert) brightness = 255 - brightness;

                    const charIndex = Math.floor((brightness / 255) * (chars.length - 1));
                    const char = chars[charIndex] || chars[0];

                    // Apply different color modes
                    let color = null;  // Track the color for animation
                    switch(colorMode) {
                        case 'html':
                            // Apply color correction if in Original Colors mode
                            // Get color correction values
                            const exposureVal = parseFloat(document.getElementById('exposure').value);
                            const contrastVal = parseFloat(document.getElementById('contrast').value);
                            const saturationVal = parseFloat(document.getElementById('saturation').value);
                            const vibranceVal = parseFloat(document.getElementById('vibrance').value);
                            const hueShiftVal = parseFloat(document.getElementById('hueShift').value);
                            const gammaVal = parseFloat(document.getElementById('gamma').value);
                            const brightnessVal = parseFloat(document.getElementById('brightness').value);

                            // Apply color corrections
                            const correctedColor = applyColorCorrection(r, g, b, exposureVal, contrastVal, saturationVal, vibranceVal, hueShiftVal, gammaVal, brightnessVal);

                            color = `rgb(${correctedColor.r},${correctedColor.g},${correctedColor.b})`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'duotone':
                            const mix = brightness / 255;
                            const textCol = hexToRgb(document.getElementById('textColor').value);
                            const bgCol = hexToRgb(document.getElementById('bgColor').value);
                            const mixedR = Math.floor(textCol.r * (1 - mix) + bgCol.r * mix);
                            const mixedG = Math.floor(textCol.g * (1 - mix) + bgCol.g * mix);
                            const mixedB = Math.floor(textCol.b * (1 - mix) + bgCol.b * mix);
                            color = `rgb(${mixedR},${mixedG},${mixedB})`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'gradient':
                            const gradPos = brightness / 255;
                            const col1 = hexToRgb(document.getElementById('textColor').value);
                            const col2 = hexToRgb(document.getElementById('bgColor').value);
                            const gradR = Math.floor(col1.r * (1 - gradPos) + col2.r * gradPos);
                            const gradG = Math.floor(col1.g * (1 - gradPos) + col2.g * gradPos);
                            const gradB = Math.floor(col1.b * (1 - gradPos) + col2.b * gradPos);
                            color = `rgb(${gradR},${gradG},${gradB})`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'matrix':
                            const greenShade = Math.floor(100 + brightness * 0.6);
                            color = `rgb(0,${greenShade},0)`;
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'retro':
                            const retroColors = ['#FFB700', '#FF6B6B', '#4ECDC4', '#95E77E'];
                            const retroIndex = Math.floor((brightness / 255) * retroColors.length);
                            color = retroColors[Math.min(retroIndex, retroColors.length - 1)];
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        case 'cyberpunk':
                            const cyberColors = ['#F72585', '#B5179E', '#7209B7', '#560BAD', '#480CA8'];
                            const cyberIndex = Math.floor((brightness / 255) * cyberColors.length);
                            color = cyberColors[Math.min(cyberIndex, cyberColors.length - 1)];
                            htmlAscii += `<span style="color:${color}">${char}</span>`;
                            ascii += char;
                            break;
                        default: // mono
                            ascii += char;
                            color = null;  // No color for mono mode
                    }

                    // Store the color for this character position
                    rowColorData.push(color);
                }
                colorData.push(rowColorData);  // Store this row's colors
                ascii += '\n';
                if (colorMode !== 'mono') htmlAscii += '<br>';
            }

            // FIXED: Store clean ASCII data regardless of color mode
            currentAsciiData = ascii;  // This is always plain text
            currentColorData = colorData;  // Store color data for animation

            // Update output with centered wrapper
            if (colorMode !== 'mono') {
                asciiOutput.innerHTML = `<span class="ascii-output-inner">${htmlAscii}</span>`;
                // Store HTML version separately if needed
                window.currentHtmlAscii = htmlAscii;
            } else {
                asciiOutput.innerHTML = `<span class="ascii-output-inner">${ascii.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>`;
            }

            // Apply styling
            const fontSize = document.getElementById('fontSize').value;
            const fontWeight = document.getElementById('fontWeight').value;
            const letterSpacing = document.getElementById('letterSpacing').value;
            const lineHeight = document.getElementById('lineHeight').value;
            const textColor = document.getElementById('textColor').value;
            const bgColor = document.getElementById('bgColor').value;

            asciiOutput.style.fontSize = fontSize + 'px';
            asciiOutput.style.fontWeight = fontWeight === 'bold' ? '700' : '400';
            asciiOutput.style.letterSpacing = letterSpacing + 'px';
            asciiOutput.style.lineHeight = lineHeight;
            asciiOutput.style.transform = 'none'; // Reset any video mode scaling
            asciiOutput.style.marginBottom = '0'; // Reset negative margin from video mode

            if (colorMode === 'mono') {
                asciiOutput.style.color = textColor;
            }

            // Set background based on mode
            if (colorMode === 'matrix') {
                asciiOutput.style.backgroundColor = '#0a0a0a';
            } else if (colorMode === 'retro') {
                asciiOutput.style.backgroundColor = '#1A1A2E';
            } else if (colorMode === 'cyberpunk') {
                asciiOutput.style.backgroundColor = '#0D0221';
            } else {
                asciiOutput.style.backgroundColor = bgColor;
            }
        }

        // Apply color correction with extreme ranges
        // Order: exposure → gamma → brightness → contrast → saturation → vibrance → hue
        function applyColorCorrection(r, g, b, exposure, contrast, saturation, vibrance, hueShift, gamma, brightness) {
            // Normalize RGB to 0-1 range
            r /= 255;
            g /= 255;
            b /= 255;

            // 1. Apply exposure (multiplicative brightness)
            r *= exposure;
            g *= exposure;
            b *= exposure;

            // 2. Apply gamma correction (affects midtones)
            r = Math.pow(r, 1 / gamma);
            g = Math.pow(g, 1 / gamma);
            b = Math.pow(b, 1 / gamma);

            // 3. Apply brightness (additive, -100 to +100 range)
            const brightnessFactor = brightness / 255; // Convert to 0-1 range
            r += brightnessFactor;
            g += brightnessFactor;
            b += brightnessFactor;

            // 4. Apply contrast (around midpoint 0.5)
            r = ((r - 0.5) * contrast + 0.5);
            g = ((g - 0.5) * contrast + 0.5);
            b = ((b - 0.5) * contrast + 0.5);

            // Convert back to 0-255 for HSL operations
            r = Math.max(0, Math.min(1, r)) * 255;
            g = Math.max(0, Math.min(1, g)) * 255;
            b = Math.max(0, Math.min(1, b)) * 255;

            // 5. Apply saturation
            if (saturation !== 1) {
                const hsl = rgbToHsl(r, g, b);
                hsl.s = Math.max(0, Math.min(100, hsl.s * saturation));
                const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                r = rgb.r;
                g = rgb.g;
                b = rgb.b;
            }

            // 6. Apply vibrance (boost low-saturation colors more)
            if (vibrance !== 0) {
                const hsl = rgbToHsl(r, g, b);
                const currentSat = hsl.s / 100; // 0-1
                // Vibrance boosts low-saturation colors more than high-saturation
                const boostAmount = vibrance * (1 - currentSat) * 50; // Adaptive boost
                hsl.s = Math.max(0, Math.min(100, hsl.s + boostAmount));
                const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                r = rgb.r;
                g = rgb.g;
                b = rgb.b;
            }

            // 7. Apply hue shift
            if (hueShift !== 0) {
                const hsl = rgbToHsl(r, g, b);
                hsl.h = (hsl.h + hueShift + 360) % 360;
                const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                r = rgb.r;
                g = rgb.g;
                b = rgb.b;
            }

            // Final clamp to 0-255
            r = Math.max(0, Math.min(255, Math.round(r)));
            g = Math.max(0, Math.min(255, Math.round(g)));
            b = Math.max(0, Math.min(255, Math.round(b)));

            return { r, g, b };
        }

        // Convert RGB to HSL
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        // Convert HSL to RGB
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;

            let r, g, b;

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;

                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        function getBrightness(r, g, b, algorithm) {
            switch (algorithm) {
                case 'average':
                    return (r + g + b) / 3;
                case 'luminosity':
                    return 0.21 * r + 0.72 * g + 0.07 * b;
                case 'lightness':
                    return (Math.max(r, g, b) + Math.min(r, g, b)) / 2;
                case 'value':
                    return Math.max(r, g, b);
                case 'luma':
                    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
                default:
                    return (r + g + b) / 3;
            }
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Export functions
        function exportText(customFilename) {
            let filename = 'ascii-art.txt';

            // Add frame info for video mode
            if (isVideoMode && videoKeyframes.length > 0) {
                const frame = videoKeyframes[selectedKeyframeIndex];
                const timestamp = frame.timestamp.toFixed(1);
                filename = `ascii_frame_${selectedKeyframeIndex + 1}_${timestamp}s.txt`;
            }

            if (customFilename) {
                filename = `${customFilename}.txt`;
            }

            const blob = new Blob([currentAsciiData], { type: 'text/plain' });
            downloadFile(blob, filename);
        }

        function exportHTML() {
            const asciiOutput = document.getElementById('asciiOutput');
            const colorMode = document.getElementById('colorMode').value;
            const fontSize = asciiOutput.style.fontSize;
            const fontWeight = asciiOutput.style.fontWeight;
            const letterSpacing = asciiOutput.style.letterSpacing;
            const lineHeight = asciiOutput.style.lineHeight;
            const textColor = document.getElementById('textColor').value;
            let bgColor = document.getElementById('bgColor').value;

            // Set background based on mode
            if (colorMode === 'matrix') {
                bgColor = '#0a0a0a';
            } else if (colorMode === 'retro') {
                bgColor = '#1A1A2E';
            } else if (colorMode === 'cyberpunk') {
                bgColor = '#0D0221';
            }

            const htmlContent = colorMode !== 'mono' ? asciiOutput.innerHTML : currentAsciiData.replace(/\n/g, '<br>');

            const html = `<!DOCTYPE html>
<html><head><title>ASCII Art - YS Studio ARTIFACT_#001</title>
<meta charset="UTF-8">
<style>
@font-face {
    font-family: 'Courier Prime';
    src: local('Courier Prime'), local('Courier New'), monospace;
}
body {
    background: ${bgColor};
    color: ${textColor};
    font-family: 'Courier Prime', 'Courier New', monospace;
    white-space: pre;
    font-size: ${fontSize};
    font-weight: ${fontWeight};
    letter-spacing: ${letterSpacing};
    line-height: ${lineHeight};
    padding: 40px;
    margin: 0;
}
span {
    white-space: pre;
}
</style>
</head><body>${htmlContent}</body></html>`;

            let filename = 'ascii-art.html';

            // Add frame info for video mode
            if (isVideoMode && videoKeyframes.length > 0) {
                const frame = videoKeyframes[selectedKeyframeIndex];
                const timestamp = frame.timestamp.toFixed(1);
                filename = `ascii_frame_${selectedKeyframeIndex + 1}_${timestamp}s.html`;
            }

            const blob = new Blob([html], { type: 'text/html' });
            downloadFile(blob, filename);
        }

        // New unified PNG export function
        function exportPNG() {
            // In video mode, calculate dimensions based on current frame
            if (isVideoMode && videoKeyframes.length > 0) {
                const frame = videoKeyframes[selectedKeyframeIndex];
                const dimensions = calculateASCIIDimensions(frame.videoWidth, frame.videoHeight);

                if (!dimensions) {
                    alert('Cannot export with current font settings. Please adjust font size, letter spacing, or line height.');
                    return;
                }

                // Calculate actual output dimensions
                const outputWidth = Math.ceil(dimensions.asciiWidth * dimensions.charWidth);
                const outputHeight = Math.ceil(dimensions.asciiHeight * dimensions.charHeight);

                exportImageWithResolution(outputWidth, outputHeight, false);
            } else {
                // For images, use default 2K resolution
                exportImageWithResolution(1920, 1080, false);
            }
        }

        function exportImageWithResolution(targetWidth, targetHeight, withAlpha) {
            if (!currentAsciiData) {
                alert('Please generate ASCII art first');
                return;
            }

            const asciiOutput = document.getElementById('asciiOutput');
            const colorMode = document.getElementById('colorMode').value;

            // Create a temporary container to measure actual dimensions
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.whiteSpace = 'pre';
            tempDiv.style.fontFamily = asciiOutput.style.fontFamily;
            tempDiv.style.fontSize = asciiOutput.style.fontSize;
            tempDiv.style.fontWeight = asciiOutput.style.fontWeight;
            tempDiv.style.letterSpacing = asciiOutput.style.letterSpacing;
            tempDiv.style.lineHeight = asciiOutput.style.lineHeight;

            if (colorMode !== 'mono') {
                tempDiv.innerHTML = asciiOutput.innerHTML;
            } else {
                tempDiv.textContent = currentAsciiData;
            }

            document.body.appendChild(tempDiv);

            // Get actual dimensions of ASCII art
            const actualWidth = tempDiv.scrollWidth;
            const actualHeight = tempDiv.scrollHeight;

            document.body.removeChild(tempDiv);

            // Calculate scale to fit target resolution while maintaining aspect ratio
            const scaleX = targetWidth / actualWidth;
            const scaleY = targetHeight / actualHeight;
            const scale = Math.min(scaleX, scaleY) * 0.9; // 0.9 for some padding

            // Calculate final canvas size
            const canvasWidth = Math.floor(actualWidth * scale);
            const canvasHeight = Math.floor(actualHeight * scale);

            // Center the content
            const offsetX = (targetWidth - canvasWidth) / 2;
            const offsetY = (targetHeight - canvasHeight) / 2;

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = targetWidth;
            exportCanvas.height = targetHeight;
            const ctx = exportCanvas.getContext('2d');

            // Set background
            let bgColor = document.getElementById('bgColor').value;
            if (colorMode === 'matrix') {
                bgColor = '#0a0a0a';
            } else if (colorMode === 'retro') {
                bgColor = '#1A1A2E';
            } else if (colorMode === 'cyberpunk') {
                bgColor = '#0D0221';
            }

            if (!withAlpha) {
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, targetWidth, targetHeight);
            }

            // Set text properties
            const fontSize = parseFloat(asciiOutput.style.fontSize) * scale;
            const fontWeight = asciiOutput.style.fontWeight;
            const letterSpacing = parseFloat(asciiOutput.style.letterSpacing || 0) * scale;
            const lineHeight = parseFloat(asciiOutput.style.lineHeight || 1);

            ctx.font = `${fontWeight === '700' || fontWeight === 'bold' ? 'bold' : 'normal'} ${fontSize}px 'Courier New', monospace`;
            ctx.textBaseline = 'top';

            const lines = currentAsciiData.split('\n');
            const actualLineHeight = fontSize * lineHeight;

            // Handle different color modes
            if (colorMode === 'mono') {
                ctx.fillStyle = document.getElementById('textColor').value;
                lines.forEach((line, y) => {
                    let x = offsetX;
                    for (let i = 0; i < line.length; i++) {
                        ctx.fillText(line[i], x, offsetY + (y * actualLineHeight));
                        x += fontSize * 0.6 + letterSpacing;
                    }
                });
            } else {
                // For colored modes, we need to extract colors from the HTML
                const tempDiv2 = document.createElement('div');
                tempDiv2.innerHTML = asciiOutput.innerHTML;
                const spans = tempDiv2.querySelectorAll('span');
                const brs = tempDiv2.querySelectorAll('br');

                let lineY = 0;
                let lineX = offsetX;
                let charIndex = 0;

                // Parse the HTML to get colors
                const coloredChars = [];
                let currentLine = [];

                asciiOutput.childNodes.forEach(node => {
                    if (node.nodeName === 'SPAN') {
                        const color = node.style.color || document.getElementById('textColor').value;
                        currentLine.push({ char: node.textContent, color: color });
                    } else if (node.nodeName === 'BR') {
                        coloredChars.push(currentLine);
                        currentLine = [];
                    } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                        currentLine.push({ char: node.textContent, color: document.getElementById('textColor').value });
                    }
                });
                if (currentLine.length > 0) coloredChars.push(currentLine);

                // Draw colored characters
                coloredChars.forEach((line, y) => {
                    let x = offsetX;
                    line.forEach(charObj => {
                        ctx.fillStyle = charObj.color;
                        ctx.fillText(charObj.char, x, offsetY + (y * actualLineHeight));
                        x += fontSize * 0.6 + letterSpacing;
                    });
                });
            }

            // Generate filename
            let filename = `ascii-art-${targetWidth}x${targetHeight}${withAlpha ? '-alpha' : ''}.png`;

            // Add frame info for video mode
            if (isVideoMode && videoKeyframes.length > 0) {
                const frame = videoKeyframes[selectedKeyframeIndex];
                const timestamp = frame.timestamp.toFixed(1);
                filename = `ascii_frame_${selectedKeyframeIndex + 1}_${timestamp}s_${targetWidth}x${targetHeight}.png`;
            }

            exportCanvas.toBlob((blob) => {
                downloadFile(blob, filename);
            }, 'image/png');
        }

        function copyToClipboard() {
            if (!currentAsciiData) {
                alert('Please generate ASCII art first');
                return;
            }

            navigator.clipboard.writeText(currentAsciiData).then(() => {
                // Visual feedback
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#000';
                btn.style.color = '#fff';

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.style.color = '';
                }, 1500);
            });
        }

        function resetAll() {
            stopKeyframePlayback(); // Stop playback if active
            currentImage = null;
            currentAsciiData = '';
            currentVideo = null;
            isVideoMode = false;
            videoKeyframes = [];
            selectedKeyframeIndex = 0;

            previewContainer.style.display = 'none';
            uploadArea.style.display = 'block';
            hideVideoGrid();
            hideVideoProcessing();

            asciiOutput.innerHTML = '<span class="ascii-output-inner">// ascii interpreter\n// waiting for image input...\n// drop or select an image to begin</span>';
            fileInput.value = '';

            // Reset controls to defaults
            document.getElementById('width').value = 100;
            document.getElementById('widthValue').textContent = '100';
            document.getElementById('charSet').value = 'standard';
            document.getElementById('algorithm').value = 'average';
            document.getElementById('colorMode').value = 'mono';
            document.getElementById('textColor').value = '#000000';
            document.getElementById('bgColor').value = '#FFFFFF';
            document.getElementById('invert').value = 'false';
            document.getElementById('fontSize').value = 12;
            document.getElementById('fontSizeValue').textContent = '12px';
            document.getElementById('fontWeight').value = 'normal';
            document.getElementById('customChars').value = '';
            document.getElementById('customChars').disabled = true;

            // Reset preset selection
            document.querySelectorAll('.preset-btn').forEach((btn, index) => {
                btn.classList.toggle('active', index === 0);
            });
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // vid-to-ASCII Preset Integration
        // Extract all current parameters
        window.extractASCIIParams = function() {
            return {
                width: parseInt(document.getElementById('width').value),
                charSet: document.getElementById('charSet').value,
                customChars: document.getElementById('customChars').value,
                algorithm: document.getElementById('algorithm').value,
                colorMode: document.getElementById('colorMode').value,
                invert: document.getElementById('invert').value === 'true',
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontWeight: document.getElementById('fontWeight').value,
                letterSpacing: parseFloat(document.getElementById('letterSpacing').value),
                lineHeight: parseFloat(document.getElementById('lineHeight').value),
                textColor: document.getElementById('textColor').value,
                bgColor: document.getElementById('bgColor').value,
                // Color correction parameters
                exposure: parseFloat(document.getElementById('exposure').value),
                contrast: parseFloat(document.getElementById('contrast').value),
                saturation: parseFloat(document.getElementById('saturation').value),
                vibrance: parseFloat(document.getElementById('vibrance').value),
                hueShift: parseFloat(document.getElementById('hueShift').value),
                gamma: parseFloat(document.getElementById('gamma').value),
                brightness: parseFloat(document.getElementById('brightness').value)
            };
        }

        // Apply preset parameters
        window.applyASCIIPreset = function(params) {
            // Apply all parameters
            if (params.width !== undefined) {
                document.getElementById('width').value = params.width;
                document.getElementById('widthValue').textContent = params.width;
            }
            if (params.charSet !== undefined) {
                document.getElementById('charSet').value = params.charSet;
                // Enable custom chars input if needed
                document.getElementById('customChars').disabled = params.charSet !== 'custom';
            }
            if (params.customChars !== undefined) {
                document.getElementById('customChars').value = params.customChars;
            }
            if (params.algorithm !== undefined) {
                document.getElementById('algorithm').value = params.algorithm;
            }
            if (params.colorMode !== undefined) {
                document.getElementById('colorMode').value = params.colorMode;
            }
            if (params.invert !== undefined) {
                document.getElementById('invert').value = params.invert ? 'true' : 'false';
            }
            if (params.fontSize !== undefined) {
                document.getElementById('fontSize').value = params.fontSize;
                document.getElementById('fontSizeValue').textContent = params.fontSize + 'px';
            }
            if (params.fontWeight !== undefined) {
                document.getElementById('fontWeight').value = params.fontWeight;
            }
            if (params.letterSpacing !== undefined) {
                document.getElementById('letterSpacing').value = params.letterSpacing;
                document.getElementById('letterSpacingValue').textContent = params.letterSpacing + 'px';
            }
            if (params.lineHeight !== undefined) {
                document.getElementById('lineHeight').value = params.lineHeight;
                document.getElementById('lineHeightValue').textContent = params.lineHeight;
            }
            if (params.textColor !== undefined) {
                document.getElementById('textColor').value = params.textColor;
            }
            if (params.bgColor !== undefined) {
                document.getElementById('bgColor').value = params.bgColor;
            }

            // Apply color correction parameters (with defaults for old presets)
            if (params.exposure !== undefined) {
                document.getElementById('exposure').value = params.exposure;
                document.getElementById('exposureValue').textContent = params.exposure;
            }
            if (params.contrast !== undefined) {
                document.getElementById('contrast').value = params.contrast;
                document.getElementById('contrastValue').textContent = params.contrast;
            }
            if (params.saturation !== undefined) {
                document.getElementById('saturation').value = params.saturation;
                document.getElementById('saturationValue').textContent = params.saturation;
            }
            if (params.vibrance !== undefined) {
                document.getElementById('vibrance').value = params.vibrance;
                document.getElementById('vibranceValue').textContent = params.vibrance;
            }
            if (params.hueShift !== undefined) {
                document.getElementById('hueShift').value = params.hueShift;
                document.getElementById('hueShiftValue').textContent = params.hueShift + '°';
            }
            if (params.gamma !== undefined) {
                document.getElementById('gamma').value = params.gamma;
                document.getElementById('gammaValue').textContent = params.gamma;
            }
            if (params.brightness !== undefined) {
                document.getElementById('brightness').value = params.brightness;
                document.getElementById('brightnessValue').textContent = params.brightness;
            }

            // Show/hide color correction section based on colorMode
            const colorCorrectionSection = document.getElementById('colorCorrectionSection');
            if (params.colorMode === 'html') {
                colorCorrectionSection.style.display = 'block';
            } else {
                colorCorrectionSection.style.display = 'none';
            }

            // Re-process image if one is loaded
            if (typeof currentImage !== 'undefined' && currentImage) {
                processImage();
            } else if (isVideoMode && videoKeyframes.length > 0) {
                // If in video mode, update current frame display with new settings
                displayKeyframeASCII(videoKeyframes[selectedKeyframeIndex]);
            }
        }
    </script>

    <!-- GIF.js Library -->
    <script src="../../shared/gif.js"></script>

    <!-- Preset System Scripts -->
    <script type="module">
        import { PresetManager } from '../../shared/preset-manager.js';
        import { PresetUIComponent } from '../../shared/preset-ui-component.js';

        // Initialize preset manager for vid-to-ASCII
        const presetManager = new PresetManager('ascii-creator');
        const presetUI = new PresetUIComponent(presetManager, window.extractASCIIParams);

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', async () => {
                // Create preset UI
                presetUI.create('presetContainer');

                // Initialize with random preset
                await presetManager.initialize(window.applyASCIIPreset);
            });
        } else {
            // DOM is already ready
            presetUI.create('presetContainer');
            presetManager.initialize(window.applyASCIIPreset);
        }

        // Make preset manager available globally for debugging
        window.asciiPresetManager = presetManager;
    </script>
</body>
</html>