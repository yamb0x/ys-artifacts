<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diss mapper - YS Studio Artifacts</title>
    <link rel="stylesheet" href="../../shared/preset-ui.css">
    <style>
        /* Font Imports */
        @font-face {
            font-family: 'Basis Grotesque';
            src: url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.woff2') format('woff2'),
                 url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.woff') format('woff'),
                 url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kalice';
            src: url('../../fonts/Kalice/Kalice-Regular-alternative.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kalice';
            src: url('../../fonts/Kalice/Kalice-Italic-alternative.otf') format('opentype');
            font-weight: 400;
            font-style: italic;
            font-display: swap;
        }

        /* YS Studio Design System Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Colors */
            --ys-white: #FFFFFF;
            --ys-black: #000000;
            --ys-red: #FF0000;
            --ys-gray: #D9D9D9;

            /* Fonts */
            --font-suisse: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-sangbleu: Georgia, 'Times New Roman', serif;
            --font-basis: 'Basis Grotesque', -apple-system, sans-serif;

            /* Spacing */
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 24px;
            --spacing-lg: 40px;
            --spacing-xl: 80px;
        }

        body {
            font-family: var(--font-basis);
            color: var(--ys-black);
            background: var(--ys-white);
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header Component */
        .ys-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 57px;
            padding: 24px;
            background: var(--ys-white);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 1000;
            border-bottom: 1px solid var(--ys-black);
        }

        .header-left {
            display: flex;
            gap: 2px;
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            color: var(--ys-black);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }

        .header-left:hover {
            opacity: 0.7;
        }

        .studio-name {
            font-weight: 300;
        }

        .project-type {
            font-style: italic;
        }

        .header-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            font-weight: 300;
        }

        .header-right {
            display: flex;
            gap: 40px;
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            font-weight: 300;
        }

        .header-right a {
            color: var(--ys-black);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }

        .header-right a:hover {
            opacity: 0.6;
        }

        .header-right a.active {
            font-weight: 500;
        }

        /* Cross Elements */
        .cross-small {
            width: 12px;
            height: 12px;
            position: relative;
            color: var(--ys-black);
            display: inline-block;
        }

        .cross-small::before,
        .cross-small::after {
            content: '';
            position: absolute;
            background: currentColor;
        }

        .cross-small::before {
            width: 1px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .cross-small::after {
            width: 100%;
            height: 1px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Cross Wrapper */
        .ys-cross-wrapper {
            position: relative;
            padding: 24px;
            background: var(--ys-white);
        }

        .cross-row {
            position: absolute;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 24px;
        }

        .cross-row.top {
            top: 24px;
        }

        .cross-row.bottom {
            bottom: 24px;
        }

        /* Control Panel */
        .control-panel {
            background: var(--ys-white);
            border-right: 1px solid var(--ys-gray);
            overflow-y: auto;
            max-height: calc(100vh - 150px);
            position: sticky;
            top: 80px;
        }

        /* Main Container */
        .ys-container {
            width: 100%;
            max-width: 1920px;
            margin: 0 auto;
            padding: 80px 24px 24px;
            min-height: 100vh;
        }

        /* Title Section */
        .title-section {
            margin-bottom: 20px;
            position: relative;
        }

        .type-display-xl {
            font-family: var(--font-sangbleu);
            font-size: 120px;
            line-height: 120px;
            letter-spacing: -4.8px;
            font-style: italic;
            text-transform: lowercase;
            font-weight: 400;
            margin: 20px 0;
        }

        /* Main Workspace */
        .main-workspace {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            min-height: calc(100vh - 200px);
        }

        /* Control Section */
        .control-section {
            margin-bottom: 16px;
            padding: 12px 24px;
        }

        .section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--ys-black);
        }

        .control-group {
            margin-bottom: 8px;
        }

        /* Labels */
        label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 6px;
            font-weight: 400;
        }

        /* Inputs */
        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 6px;
            font-size: 11px;
            font-family: var(--font-basis);
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            color: var(--ys-black);
        }

        /* Sliders */
        input[type="range"] {
            width: 100%;
            height: 1px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--ys-black);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
            border: none;
        }

        /* Buttons */
        button, .button {
            padding: 10px 16px;
            font-size: 11px;
            font-family: var(--font-basis);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            background: var(--ys-white);
            color: var(--ys-black);
            border: 1px solid var(--ys-black);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover, .button:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        button.primary {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        button.primary:hover {
            background: var(--ys-white);
            color: var(--ys-black);
        }

        /* Toggle Buttons */
        .toggle-group {
            display: flex;
            gap: 8px;
        }

        .toggle-btn {
            padding: 8px 12px;
            font-size: 11px;
            text-transform: uppercase;
            flex: 1;
        }

        .toggle-btn.active {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        /* Checkboxes */
        input[type="checkbox"] {
            width: 12px;
            height: 12px;
            border: 1px solid var(--ys-black);
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            position: relative;
            background: var(--ys-white);
        }

        input[type="checkbox"]:checked {
            background: var(--ys-black);
        }

        input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--ys-white);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        /* File Upload */
        .file-upload {
            border: 2px dashed var(--ys-gray);
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s ease;
            margin-bottom: 12px;
        }

        .file-upload:hover {
            border-color: var(--ys-black);
        }

        .file-upload.active {
            border-color: var(--ys-black);
            background: rgba(0, 0, 0, 0.02);
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .upload-text {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .upload-subtext {
            font-size: 9px;
            color: var(--ys-gray);
            margin-top: 4px;
        }

        /* Canvas Area */
        .canvas-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            position: relative;
            min-height: 600px;
        }

        #outputCanvas {
            max-width: 100%;
            max-height: calc(100vh - 200px);
            border: 1px solid var(--ys-gray);
            display: block;
        }

        .canvas-placeholder {
            text-align: center;
            color: var(--ys-gray);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Slider with Value Display */
        .slider-control {
            position: relative;
        }

        .slider-value {
            position: absolute;
            right: 0;
            top: 0;
            font-size: 10px;
            color: var(--ys-gray);
        }

        /* Collapsible Sections */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 6px 0;
            border-bottom: 1px solid var(--ys-gray);
            margin-bottom: 8px;
        }

        .section-header:hover {
            opacity: 0.7;
        }

        .section-content {
            display: block;
        }

        .section-content.collapsed {
            display: none;
        }

        .collapse-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
        }

        .collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-workspace {
                grid-template-columns: 1fr;
            }

            .control-panel {
                position: static;
                max-height: none;
            }

            .type-display-xl {
                font-size: 60px;
                line-height: 60px;
            }
        }

        @media (max-width: 1024px) {
            .header-center {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .header-right {
                display: none;
            }

            .type-display-xl {
                font-size: 48px;
                line-height: 48px;
            }
        }

        /* Loading State */
        .loading {
            pointer-events: none;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="ys-header">
        <a href="/" class="header-left">
            <span class="studio-name">YAMBO STUDIO</span>
            <span>—</span>
            <span class="project-type">Artifacts</span>
        </a>
        <div class="header-center">diss mapper</div>
        <nav class="header-right">
            <a href="/about.html">About</a>
            <a href="/" class="active">Tools</a>
        </nav>
    </header>

    <!-- Main Container -->
    <div class="ys-container">
        <!-- Title Section -->
        <div class="title-section">
            <h1 class="type-display-xl">displacement mapper</h1>
        </div>

        <!-- Main Workspace -->
        <div class="main-workspace">
            <!-- Control Panel -->
            <div class="control-panel">
                <div class="ys-cross-wrapper">
                    <div class="cross-row top">
                        <div class="cross-small"></div>
                        <div class="cross-small"></div>
                    </div>

                <!-- Image Upload Section -->
                <div class="control-section">
                    <div class="section-title">Image Upload</div>
                    <div class="file-upload" id="imageUpload">
                        <input type="file" id="imageInput" accept="image/*">
                        <div class="upload-text">Drop image or click to upload</div>
                        <div class="upload-subtext">[JPG, PNG, WebP]</div>
                    </div>
                </div>

                <!-- Displacement Source Section -->
                <div class="control-section">
                    <div class="section-title">Displacement Source</div>
                    <div class="control-group">
                        <div class="toggle-group">
                            <button class="toggle-btn active" id="modeGenerate">Generate</button>
                            <button class="toggle-btn" id="modeUpload">Upload</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="useSharedMap" checked>
                            <span>Use Shared Map (X & Y)</span>
                        </label>
                    </div>
                </div>

                <!-- Pattern Generator Section -->
                <div class="control-section" id="patternSection">
                    <div class="section-header">
                        <div class="section-title" style="margin: 0;">Pattern Generator</div>
                        <span class="collapse-icon">−</span>
                    </div>
                    <div class="section-content">
                        <div class="control-group">
                            <label>Pattern Type</label>
                            <select id="patternType">
                                <option value="perlin">Perlin Noise</option>
                                <option value="sine">Sine Wave</option>
                                <option value="radial">Radial Gradient</option>
                                <option value="turbulence">Turbulence</option>
                                <option value="circular">Circular Waves</option>
                                <option value="stripes">Stripes</option>
                                <option value="checkerboard">Checkerboard</option>
                                <option value="marble">Marble</option>
                            </select>
                        </div>
                        <div class="control-group slider-control">
                            <label>Scale <span class="slider-value" id="patternScaleValue">50</span></label>
                            <input type="range" id="patternScale" min="1" max="200" value="50">
                        </div>
                        <div class="control-group slider-control">
                            <label>Frequency <span class="slider-value" id="patternFreqValue">2.0</span></label>
                            <input type="range" id="patternFreq" min="0.1" max="10" step="0.1" value="2.0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Amplitude <span class="slider-value" id="patternAmpValue">1.0</span></label>
                            <input type="range" id="patternAmp" min="0.01" max="2" step="0.01" value="1.0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Rotation <span class="slider-value" id="patternRotValue">0°</span></label>
                            <input type="range" id="patternRot" min="0" max="360" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Falloff <span class="slider-value" id="patternFalloffValue">0.0</span></label>
                            <input type="range" id="patternFalloff" min="0" max="1" step="0.01" value="0">
                        </div>
                        <div class="control-group">
                            <button id="regeneratePattern" style="width: 100%;">Regenerate Pattern</button>
                        </div>
                    </div>
                </div>

                <!-- Displacement Map Upload Section (hidden by default) -->
                <div class="control-section" id="uploadSection" style="display: none;">
                    <div class="section-title">Displacement Map Upload</div>
                    <div class="file-upload" id="dispMapUpload">
                        <input type="file" id="dispMapInput" accept="image/*">
                        <div class="upload-text">Drop displacement map</div>
                        <div class="upload-subtext">[Grayscale image]</div>
                    </div>
                </div>

                <!-- Displacement Controls Section -->
                <div class="control-section">
                    <div class="section-header">
                        <div class="section-title" style="margin: 0;">Displacement Controls</div>
                        <span class="collapse-icon">−</span>
                    </div>
                    <div class="section-content">
                        <div class="control-group slider-control">
                            <label>X Strength <span class="slider-value" id="xStrengthValue">50</span></label>
                            <input type="range" id="xStrength" min="-200" max="200" value="50">
                        </div>
                        <div class="control-group slider-control">
                            <label>Y Strength <span class="slider-value" id="yStrengthValue">50</span></label>
                            <input type="range" id="yStrength" min="-200" max="200" value="50">
                        </div>
                        <div class="control-group slider-control">
                            <label>Threshold <span class="slider-value" id="thresholdValue">0</span></label>
                            <input type="range" id="threshold" min="0" max="255" value="0">
                        </div>
                        <div class="control-group">
                            <label>Edge Mode</label>
                            <select id="edgeMode">
                                <option value="clamp">Clamp</option>
                                <option value="wrap">Wrap</option>
                                <option value="mirror">Mirror</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Preprocessing Section -->
                <div class="control-section">
                    <div class="section-header">
                        <div class="section-title" style="margin: 0;">Preprocessing</div>
                        <span class="collapse-icon">−</span>
                    </div>
                    <div class="section-content">
                        <div class="control-group slider-control">
                            <label>Blur <span class="slider-value" id="blurValue">0</span></label>
                            <input type="range" id="blur" min="0" max="20" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Gamma <span class="slider-value" id="gammaValue">1.0</span></label>
                            <input type="range" id="gamma" min="0.1" max="3" step="0.1" value="1.0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Contrast <span class="slider-value" id="contrastValue">100</span></label>
                            <input type="range" id="contrast" min="0" max="200" value="100">
                        </div>
                        <div class="control-group slider-control">
                            <label>Black Point <span class="slider-value" id="blackPointValue">0</span></label>
                            <input type="range" id="blackPoint" min="0" max="255" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>White Point <span class="slider-value" id="whitePointValue">255</span></label>
                            <input type="range" id="whitePoint" min="0" max="255" value="255">
                        </div>
                        <div class="control-group slider-control">
                            <label>Saturation <span class="slider-value" id="saturationValue">100</span></label>
                            <input type="range" id="saturation" min="0" max="200" value="100">
                        </div>
                        <div class="control-group slider-control">
                            <label>Hue <span class="slider-value" id="hueValue">0°</span></label>
                            <input type="range" id="hue" min="-180" max="180" value="0">
                        </div>
                    </div>
                </div>

                <!-- Blend Mode Section -->
                <div class="control-section">
                    <div class="section-header">
                        <div class="section-title" style="margin: 0;">Blend & Composite</div>
                        <span class="collapse-icon">−</span>
                    </div>
                    <div class="section-content">
                        <div class="control-group">
                            <label>Blend Mode</label>
                            <select id="blendMode">
                                <option value="normal">Normal</option>
                                <option value="multiply">Multiply</option>
                                <option value="screen">Screen</option>
                                <option value="overlay">Overlay</option>
                                <option value="difference">Difference</option>
                                <option value="exclusion">Exclusion</option>
                            </select>
                        </div>
                        <div class="control-group slider-control">
                            <label>Opacity <span class="slider-value" id="opacityValue">100%</span></label>
                            <input type="range" id="opacity" min="0" max="100" value="100">
                        </div>
                        <div class="control-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="showOriginal">
                                <span>Show Original</span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Chromatic Aberration Section -->
                <div class="control-section">
                    <div class="section-header">
                        <div class="section-title" style="margin: 0;">Chromatic Aberration</div>
                        <span class="collapse-icon">−</span>
                    </div>
                    <div class="section-content">
                        <div class="control-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="enableChromatic">
                                <span>Enable Chromatic Aberration</span>
                            </label>
                        </div>
                        <div class="control-group slider-control">
                            <label>Red X Offset <span class="slider-value" id="redXValue">0</span></label>
                            <input type="range" id="redX" min="-50" max="50" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Red Y Offset <span class="slider-value" id="redYValue">0</span></label>
                            <input type="range" id="redY" min="-50" max="50" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Green X Offset <span class="slider-value" id="greenXValue">0</span></label>
                            <input type="range" id="greenX" min="-50" max="50" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Green Y Offset <span class="slider-value" id="greenYValue">0</span></label>
                            <input type="range" id="greenY" min="-50" max="50" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Blue X Offset <span class="slider-value" id="blueXValue">0</span></label>
                            <input type="range" id="blueX" min="-50" max="50" value="0">
                        </div>
                        <div class="control-group slider-control">
                            <label>Blue Y Offset <span class="slider-value" id="blueYValue">0</span></label>
                            <input type="range" id="blueY" min="-50" max="50" value="0">
                        </div>
                    </div>
                </div>

                <!-- Preset Section -->
                <div class="control-section">
                    <div id="presetContainer"></div>
                </div>

                <!-- Export Section -->
                <div class="control-section">
                    <div class="section-title">Export</div>
                    <div class="control-group">
                        <label>Format</label>
                        <select id="exportFormat">
                            <option value="png">PNG</option>
                            <option value="jpeg">JPEG</option>
                            <option value="webp">WebP</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Scale</label>
                        <div class="toggle-group">
                            <button class="toggle-btn active" data-scale="1">1x</button>
                            <button class="toggle-btn" data-scale="2">2x</button>
                            <button class="toggle-btn" data-scale="4">4x</button>
                        </div>
                    </div>
                    <div class="control-group" id="qualityGroup" style="display: none;">
                        <label>Quality <span class="slider-value" id="qualityValue">95%</span></label>
                        <input type="range" id="quality" min="0" max="100" value="95">
                    </div>
                    <div class="control-group">
                        <button id="exportBtn" class="primary" style="width: 100%;">Export Image</button>
                    </div>
                </div>

                    <div class="cross-row bottom">
                        <div class="cross-small"></div>
                        <div class="cross-small"></div>
                    </div>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <canvas id="outputCanvas" width="800" height="800"></canvas>
                <div class="canvas-placeholder" id="placeholder">
                    Upload an image to begin
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script type="module">
        // Import preset system
        import { PresetManager } from '../../shared/preset-manager.js';
        import { PresetUIComponent } from '../../shared/preset-ui-component.js';

        // Global state
        let sourceImage = null;
        let displacementMap = null;
        let engine = null;

        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);

        function init() {
            setupEventListeners();
            setupCollapsibleSections();
            initializeCanvas();
            initializePresetSystem();
        }

        // Canvas initialization
        function initializeCanvas() {
            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Event Listeners
        function setupEventListeners() {
            // Image upload
            const imageUpload = document.getElementById('imageUpload');
            const imageInput = document.getElementById('imageInput');

            imageUpload.addEventListener('click', () => imageInput.click());
            imageUpload.addEventListener('dragover', handleDragOver);
            imageUpload.addEventListener('drop', handleImageDrop);
            imageInput.addEventListener('change', handleImageSelect);

            // Displacement map upload
            const dispMapUpload = document.getElementById('dispMapUpload');
            const dispMapInput = document.getElementById('dispMapInput');

            dispMapUpload.addEventListener('click', () => dispMapInput.click());
            dispMapUpload.addEventListener('dragover', handleDragOver);
            dispMapUpload.addEventListener('drop', handleDispMapDrop);
            dispMapUpload.addEventListener('dragleave', (e) => {
                e.currentTarget.classList.remove('active');
            });
            dispMapInput.addEventListener('change', handleDispMapSelect);

            // Mode toggle
            document.getElementById('modeGenerate').addEventListener('click', () => setMode('generate'));
            document.getElementById('modeUpload').addEventListener('click', () => setMode('upload'));

            // Slider value displays
            setupSliderValueDisplay('patternScale', 'patternScaleValue');
            setupSliderValueDisplay('patternFreq', 'patternFreqValue', 1);
            setupSliderValueDisplay('patternAmp', 'patternAmpValue', 2);
            setupSliderValueDisplay('patternRot', 'patternRotValue', 0, '°');
            setupSliderValueDisplay('patternFalloff', 'patternFalloffValue', 2);
            setupSliderValueDisplay('xStrength', 'xStrengthValue');
            setupSliderValueDisplay('yStrength', 'yStrengthValue');
            setupSliderValueDisplay('threshold', 'thresholdValue');
            setupSliderValueDisplay('blur', 'blurValue');
            setupSliderValueDisplay('gamma', 'gammaValue', 1);
            setupSliderValueDisplay('contrast', 'contrastValue');
            setupSliderValueDisplay('blackPoint', 'blackPointValue');
            setupSliderValueDisplay('whitePoint', 'whitePointValue');
            setupSliderValueDisplay('saturation', 'saturationValue');
            setupSliderValueDisplay('hue', 'hueValue', 0, '°');
            setupSliderValueDisplay('opacity', 'opacityValue', 0, '%');
            setupSliderValueDisplay('quality', 'qualityValue', 0, '%');
            setupSliderValueDisplay('redX', 'redXValue');
            setupSliderValueDisplay('redY', 'redYValue');
            setupSliderValueDisplay('greenX', 'greenXValue');
            setupSliderValueDisplay('greenY', 'greenYValue');
            setupSliderValueDisplay('blueX', 'blueXValue');
            setupSliderValueDisplay('blueY', 'blueYValue');

            // Control changes
            document.getElementById('patternType').addEventListener('change', regeneratePattern);
            document.getElementById('patternScale').addEventListener('input', regeneratePattern);
            document.getElementById('patternFreq').addEventListener('input', regeneratePattern);
            document.getElementById('patternAmp').addEventListener('input', regeneratePattern);
            document.getElementById('patternRot').addEventListener('input', regeneratePattern);
            document.getElementById('patternFalloff').addEventListener('input', regeneratePattern);
            document.getElementById('regeneratePattern').addEventListener('click', regeneratePattern);

            document.getElementById('xStrength').addEventListener('input', render);
            document.getElementById('yStrength').addEventListener('input', render);
            document.getElementById('threshold').addEventListener('input', render);
            document.getElementById('edgeMode').addEventListener('change', render);
            document.getElementById('blur').addEventListener('input', render);
            document.getElementById('gamma').addEventListener('input', render);
            document.getElementById('contrast').addEventListener('input', render);
            document.getElementById('blackPoint').addEventListener('input', render);
            document.getElementById('whitePoint').addEventListener('input', render);
            document.getElementById('saturation').addEventListener('input', render);
            document.getElementById('hue').addEventListener('input', render);
            document.getElementById('blendMode').addEventListener('change', render);
            document.getElementById('opacity').addEventListener('input', render);
            document.getElementById('showOriginal').addEventListener('change', render);

            // Chromatic aberration
            document.getElementById('enableChromatic').addEventListener('change', render);
            document.getElementById('redX').addEventListener('input', render);
            document.getElementById('redY').addEventListener('input', render);
            document.getElementById('greenX').addEventListener('input', render);
            document.getElementById('greenY').addEventListener('input', render);
            document.getElementById('blueX').addEventListener('input', render);
            document.getElementById('blueY').addEventListener('input', render);

            // Export format
            document.getElementById('exportFormat').addEventListener('change', (e) => {
                const qualityGroup = document.getElementById('qualityGroup');
                qualityGroup.style.display = (e.target.value === 'jpeg' || e.target.value === 'webp') ? 'block' : 'none';
            });

            // Export scale buttons
            document.querySelectorAll('[data-scale]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('[data-scale]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            // Export button
            document.getElementById('exportBtn').addEventListener('click', exportImage);
        }

        function setupSliderValueDisplay(sliderId, valueId, decimals = 0, suffix = '') {
            const slider = document.getElementById(sliderId);
            const display = document.getElementById(valueId);
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                display.textContent = value.toFixed(decimals) + suffix;
            });
        }

        function setupCollapsibleSections() {
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const icon = header.querySelector('.collapse-icon');
                    content.classList.toggle('collapsed');
                    icon.textContent = content.classList.contains('collapsed') ? '+' : '−';
                });
            });
        }

        // Mode switching
        function setMode(mode) {
            if (mode === 'generate') {
                document.getElementById('modeGenerate').classList.add('active');
                document.getElementById('modeUpload').classList.remove('active');
                document.getElementById('patternSection').style.display = 'block';
                document.getElementById('uploadSection').style.display = 'none';
                regeneratePattern();
            } else {
                document.getElementById('modeGenerate').classList.remove('active');
                document.getElementById('modeUpload').classList.add('active');
                document.getElementById('patternSection').style.display = 'none';
                document.getElementById('uploadSection').style.display = 'block';
            }
        }

        // Image handling
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('active');
        }

        function handleImageDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        }

        function handleImageSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    sourceImage = img;
                    document.getElementById('placeholder').style.display = 'none';
                    regeneratePattern();
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Displacement map handling
        function handleDispMapDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadDispMap(files[0]);
            }
        }

        function handleDispMapSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                loadDispMap(files[0]);
            }
        }

        function loadDispMap(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = sourceImage ? sourceImage.width : img.width;
                    canvas.height = sourceImage ? sourceImage.height : img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    displacementMap = canvas;
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Pattern Generator
        function regeneratePattern() {
            if (!sourceImage) return;

            const type = document.getElementById('patternType').value;
            const scale = parseInt(document.getElementById('patternScale').value);
            const freq = parseFloat(document.getElementById('patternFreq').value);
            const amp = parseFloat(document.getElementById('patternAmp').value);
            const rot = parseInt(document.getElementById('patternRot').value);
            const falloff = parseFloat(document.getElementById('patternFalloff').value);

            const canvas = document.createElement('canvas');
            canvas.width = sourceImage.width;
            canvas.height = sourceImage.height;
            const ctx = canvas.getContext('2d');

            switch(type) {
                case 'perlin':
                    generatePerlinNoise(ctx, canvas.width, canvas.height, scale, amp, falloff);
                    break;
                case 'sine':
                    generateSineWave(ctx, canvas.width, canvas.height, freq, amp, rot, falloff);
                    break;
                case 'radial':
                    generateRadialGradient(ctx, canvas.width, canvas.height, amp, falloff);
                    break;
                case 'turbulence':
                    generateTurbulence(ctx, canvas.width, canvas.height, scale, amp, falloff);
                    break;
                case 'circular':
                    generateCircularWaves(ctx, canvas.width, canvas.height, freq, amp, falloff);
                    break;
                case 'stripes':
                    generateStripes(ctx, canvas.width, canvas.height, scale, rot, amp, falloff);
                    break;
                case 'checkerboard':
                    generateCheckerboard(ctx, canvas.width, canvas.height, scale, amp, falloff);
                    break;
                case 'marble':
                    generateMarble(ctx, canvas.width, canvas.height, scale, amp, falloff);
                    break;
            }

            displacementMap = canvas;
            render();
        }

        // Helper function to apply falloff
        function applyFalloff(value, falloff) {
            // value should be 0-1
            // falloff controls the smoothing: 0 = no change, 1 = smooth to center
            if (falloff === 0) return value;

            // Apply power curve for smooth falloff
            const curve = 1 - falloff;
            return Math.pow(value, Math.pow(2, -falloff * 3));
        }

        // Pattern generation functions with amplitude and falloff
        function generatePerlinNoise(ctx, w, h, scale, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Simple noise (using Math.random as placeholder for Perlin)
                    let value = Math.random();

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff from center
                    if (falloff > 0) {
                        const dx = x - w/2;
                        const dy = y - h/2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    // Clamp and convert to 0-255
                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateSineWave(ctx, w, h, freq, amplitude, rotation, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);
            const rad = rotation * Math.PI / 180;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Rotate coordinates
                    const dx = x - w/2;
                    const dy = y - h/2;
                    const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
                    const ry = dx * Math.sin(rad) + dy * Math.cos(rad);

                    // Generate sine wave (0 to 1)
                    let value = (Math.sin((rx / w) * freq * Math.PI * 2) + 1) * 0.5;

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff
                    if (falloff > 0) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateRadialGradient(ctx, w, h, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = x - w/2;
                    const dy = y - h/2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    let value = 1 - (dist / maxDist); // Gradient from center

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff (additional smoothing)
                    if (falloff > 0) {
                        value = applyFalloff(value, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateTurbulence(ctx, w, h, scale, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Turbulence pattern
                    let value = Math.abs(Math.sin(x / scale) * Math.cos(y / scale));
                    value += Math.abs(Math.sin(x / (scale * 0.5)) * Math.cos(y / (scale * 0.5))) * 0.5;
                    value = value / 1.5; // Normalize

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff
                    if (falloff > 0) {
                        const dx = x - w/2;
                        const dy = y - h/2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateCircularWaves(ctx, w, h, freq, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const cx = w / 2;
            const cy = h / 2;
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = x - cx;
                    const dy = y - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Circular wave
                    let value = (Math.sin(dist / maxDist * freq * Math.PI * 4) + 1) * 0.5;

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff
                    if (falloff > 0) {
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateStripes(ctx, w, h, scale, rotation, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);
            const rad = rotation * Math.PI / 180;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = x - w/2;
                    const dy = y - h/2;

                    // Rotate coordinates
                    const rx = dx * Math.cos(rad) - dy * Math.sin(rad) + w/2;

                    // Generate stripe pattern (0-1)
                    let value = (Math.sin(rx / scale * Math.PI) + 1) * 0.5;

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff
                    if (falloff > 0) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateCheckerboard(ctx, w, h, scale, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = x - w/2;
                    const dy = y - h/2;

                    // Checkerboard pattern
                    const isEven = (Math.floor(x / scale) + Math.floor(y / scale)) % 2 === 0;
                    let value = isEven ? 1 : 0;

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff
                    if (falloff > 0) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateMarble(ctx, w, h, scale, amplitude, falloff) {
            const imageData = ctx.createImageData(w, h);
            const maxDist = Math.sqrt((w/2) ** 2 + (h/2) ** 2);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const dx = x - w/2;
                    const dy = y - h/2;

                    // Marble pattern with multiple frequencies
                    let value = Math.abs(Math.sin((x + y) / scale));
                    value += Math.abs(Math.sin((x - y) / (scale * 0.7))) * 0.5;
                    value = value / 1.5; // Normalize

                    // Apply amplitude
                    value = value * amplitude;

                    // Apply falloff
                    if (falloff > 0) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distNorm = 1 - (dist / maxDist);
                        value = value * applyFalloff(distNorm, falloff);
                    }

                    const gray = Math.floor(Math.max(0, Math.min(1, value)) * 255);
                    const i = (y * w + x) * 4;
                    imageData.data[i] = gray;
                    imageData.data[i + 1] = gray;
                    imageData.data[i + 2] = gray;
                    imageData.data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // Main render function
        function render() {
            if (!sourceImage || !displacementMap) return;

            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');

            // Resize canvas to image size
            canvas.width = sourceImage.width;
            canvas.height = sourceImage.height;

            // Show original if checked
            if (document.getElementById('showOriginal').checked) {
                ctx.drawImage(sourceImage, 0, 0);
                return;
            }

            // Apply preprocessing
            const processed = applyPreprocessing(sourceImage);

            // Apply displacement
            let displaced = applyDisplacement(processed, displacementMap);

            // Apply chromatic aberration if enabled
            if (document.getElementById('enableChromatic').checked) {
                displaced = applyChromaticAberration(displaced);
            }

            // Draw result
            ctx.putImageData(displaced, 0, 0);

            // Apply blend mode if needed
            const blendMode = document.getElementById('blendMode').value;
            const opacity = parseInt(document.getElementById('opacity').value) / 100;

            if (blendMode !== 'normal' || opacity < 1) {
                ctx.globalAlpha = opacity;
                ctx.globalCompositeOperation = blendMode;
                ctx.drawImage(sourceImage, 0, 0);
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        // Helper functions for HSL conversion
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function applyPreprocessing(img) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply gamma
            const gamma = parseFloat(document.getElementById('gamma').value);
            if (gamma !== 1.0) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.pow(data[i] / 255, 1 / gamma) * 255;
                    data[i + 1] = Math.pow(data[i + 1] / 255, 1 / gamma) * 255;
                    data[i + 2] = Math.pow(data[i + 2] / 255, 1 / gamma) * 255;
                }
            }

            // Apply contrast
            const contrast = (parseInt(document.getElementById('contrast').value) - 100) / 100;
            const factor = (259 * (contrast * 255 + 255)) / (255 * (259 - contrast * 255));
            for (let i = 0; i < data.length; i += 4) {
                data[i] = factor * (data[i] - 128) + 128;
                data[i + 1] = factor * (data[i + 1] - 128) + 128;
                data[i + 2] = factor * (data[i + 2] - 128) + 128;
            }

            // Apply levels
            const blackPoint = parseInt(document.getElementById('blackPoint').value);
            const whitePoint = parseInt(document.getElementById('whitePoint').value);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = ((data[i] - blackPoint) / (whitePoint - blackPoint)) * 255;
                data[i + 1] = ((data[i + 1] - blackPoint) / (whitePoint - blackPoint)) * 255;
                data[i + 2] = ((data[i + 2] - blackPoint) / (whitePoint - blackPoint)) * 255;

                // Clamp
                data[i] = Math.max(0, Math.min(255, data[i]));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1]));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2]));
            }

            // Apply saturation and hue
            const saturation = parseInt(document.getElementById('saturation').value) / 100;
            const hueShift = parseInt(document.getElementById('hue').value) / 360;

            if (saturation !== 1.0 || hueShift !== 0) {
                for (let i = 0; i < data.length; i += 4) {
                    let [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);

                    // Apply saturation
                    s = Math.max(0, Math.min(1, s * saturation));

                    // Apply hue shift
                    h = (h + hueShift + 1) % 1;

                    const [r, g, b] = hslToRgb(h, s, l);
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Apply blur
            const blur = parseInt(document.getElementById('blur').value);
            if (blur > 0) {
                ctx.filter = `blur(${blur}px)`;
                ctx.drawImage(canvas, 0, 0);
                ctx.filter = 'none';
            }

            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        function applyDisplacement(sourceImageData, dispMap) {
            const w = sourceImageData.width;
            const h = sourceImageData.height;

            // Get displacement map data
            const dispCanvas = document.createElement('canvas');
            dispCanvas.width = w;
            dispCanvas.height = h;
            const dispCtx = dispCanvas.getContext('2d');
            dispCtx.drawImage(dispMap, 0, 0, w, h);
            const dispData = dispCtx.getImageData(0, 0, w, h);

            const output = new ImageData(w, h);
            const xStrength = parseInt(document.getElementById('xStrength').value);
            const yStrength = parseInt(document.getElementById('yStrength').value);
            const threshold = parseInt(document.getElementById('threshold').value);
            const edgeMode = document.getElementById('edgeMode').value;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;

                    // Read displacement values (using red channel)
                    const dispValue = dispData.data[i];

                    // Apply threshold - values below threshold don't displace
                    let dispStrength = 1.0;
                    if (dispValue < threshold) {
                        // Smooth falloff near threshold for better results
                        if (threshold > 0) {
                            dispStrength = dispValue / threshold;
                        } else {
                            dispStrength = 1.0;
                        }
                    }

                    // Map displacement value to -1 to 1 range
                    const normalized = (dispValue / 255) * 2 - 1;

                    // Apply strength and calculate offsets
                    const xOffset = normalized * xStrength * dispStrength;
                    const yOffset = normalized * yStrength * dispStrength;

                    // Calculate source coordinates
                    let srcX = x + xOffset;
                    let srcY = y + yOffset;

                    // Handle edge mode
                    if (edgeMode === 'clamp') {
                        srcX = Math.max(0, Math.min(w - 1, srcX));
                        srcY = Math.max(0, Math.min(h - 1, srcY));
                    } else if (edgeMode === 'wrap') {
                        srcX = ((srcX % w) + w) % w;
                        srcY = ((srcY % h) + h) % h;
                    } else if (edgeMode === 'mirror') {
                        if (srcX < 0 || srcX >= w) srcX = w - Math.abs(srcX % w);
                        if (srcY < 0 || srcY >= h) srcY = h - Math.abs(srcY % h);
                    }

                    // Sample from source (with bilinear interpolation for smoother results)
                    const x1 = Math.floor(srcX);
                    const y1 = Math.floor(srcY);
                    const x2 = Math.min(x1 + 1, w - 1);
                    const y2 = Math.min(y1 + 1, h - 1);

                    const fx = srcX - x1;
                    const fy = srcY - y1;

                    // Get four surrounding pixels
                    const i1 = (y1 * w + x1) * 4;
                    const i2 = (y1 * w + x2) * 4;
                    const i3 = (y2 * w + x1) * 4;
                    const i4 = (y2 * w + x2) * 4;

                    // Bilinear interpolation for each channel
                    for (let c = 0; c < 4; c++) {
                        const top = sourceImageData.data[i1 + c] * (1 - fx) + sourceImageData.data[i2 + c] * fx;
                        const bottom = sourceImageData.data[i3 + c] * (1 - fx) + sourceImageData.data[i4 + c] * fx;
                        output.data[i + c] = top * (1 - fy) + bottom * fy;
                    }
                }
            }

            return output;
        }

        function applyChromaticAberration(imageData) {
            const w = imageData.width;
            const h = imageData.height;
            const output = new ImageData(w, h);

            // Get offset values
            const redXOffset = parseInt(document.getElementById('redX').value);
            const redYOffset = parseInt(document.getElementById('redY').value);
            const greenXOffset = parseInt(document.getElementById('greenX').value);
            const greenYOffset = parseInt(document.getElementById('greenY').value);
            const blueXOffset = parseInt(document.getElementById('blueX').value);
            const blueYOffset = parseInt(document.getElementById('blueY').value);

            // Process each pixel
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;

                    // Red channel with offset
                    const redSrcX = Math.max(0, Math.min(w - 1, x + redXOffset));
                    const redSrcY = Math.max(0, Math.min(h - 1, y + redYOffset));
                    const redSrcI = (redSrcY * w + redSrcX) * 4;
                    output.data[i] = imageData.data[redSrcI];

                    // Green channel with offset
                    const greenSrcX = Math.max(0, Math.min(w - 1, x + greenXOffset));
                    const greenSrcY = Math.max(0, Math.min(h - 1, y + greenYOffset));
                    const greenSrcI = (greenSrcY * w + greenSrcX) * 4;
                    output.data[i + 1] = imageData.data[greenSrcI + 1];

                    // Blue channel with offset
                    const blueSrcX = Math.max(0, Math.min(w - 1, x + blueXOffset));
                    const blueSrcY = Math.max(0, Math.min(h - 1, y + blueYOffset));
                    const blueSrcI = (blueSrcY * w + blueSrcX) * 4;
                    output.data[i + 2] = imageData.data[blueSrcI + 2];

                    // Alpha channel (no offset)
                    output.data[i + 3] = imageData.data[i + 3];
                }
            }

            return output;
        }

        // Export
        function exportImage() {
            const canvas = document.getElementById('outputCanvas');
            const format = document.getElementById('exportFormat').value;
            const scale = parseInt(document.querySelector('[data-scale].active').dataset.scale);

            let exportCanvas = canvas;
            if (scale > 1) {
                exportCanvas = document.createElement('canvas');
                exportCanvas.width = canvas.width * scale;
                exportCanvas.height = canvas.height * scale;
                const ctx = exportCanvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(canvas, 0, 0, exportCanvas.width, exportCanvas.height);
            }

            let dataURL;
            if (format === 'png') {
                dataURL = exportCanvas.toDataURL('image/png');
            } else if (format === 'jpeg') {
                const quality = parseInt(document.getElementById('quality').value) / 100;
                dataURL = exportCanvas.toDataURL('image/jpeg', quality);
            } else if (format === 'webp') {
                const quality = parseInt(document.getElementById('quality').value) / 100;
                dataURL = exportCanvas.toDataURL('image/webp', quality);
            }

            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `displacement_${Date.now()}.${format}`;
            a.click();
        }

        // Preset System Integration
        function initializePresetSystem() {
            const presetManager = new PresetManager('displacement-mapper');
            const presetUI = new PresetUIComponent(presetManager, 'presetContainer');

            // Define extract function
            window.extractToolParams = function() {
                return {
                    patternType: document.getElementById('patternType').value,
                    patternScale: parseInt(document.getElementById('patternScale').value),
                    patternFreq: parseFloat(document.getElementById('patternFreq').value),
                    patternAmp: parseFloat(document.getElementById('patternAmp').value),
                    patternRot: parseInt(document.getElementById('patternRot').value),
                    patternFalloff: parseFloat(document.getElementById('patternFalloff').value),
                    xStrength: parseInt(document.getElementById('xStrength').value),
                    yStrength: parseInt(document.getElementById('yStrength').value),
                    threshold: parseInt(document.getElementById('threshold').value),
                    edgeMode: document.getElementById('edgeMode').value,
                    blur: parseInt(document.getElementById('blur').value),
                    gamma: parseFloat(document.getElementById('gamma').value),
                    contrast: parseInt(document.getElementById('contrast').value),
                    blackPoint: parseInt(document.getElementById('blackPoint').value),
                    whitePoint: parseInt(document.getElementById('whitePoint').value),
                    saturation: parseInt(document.getElementById('saturation').value),
                    hue: parseInt(document.getElementById('hue').value),
                    blendMode: document.getElementById('blendMode').value,
                    opacity: parseInt(document.getElementById('opacity').value),
                    enableChromatic: document.getElementById('enableChromatic').checked,
                    redX: parseInt(document.getElementById('redX').value),
                    redY: parseInt(document.getElementById('redY').value),
                    greenX: parseInt(document.getElementById('greenX').value),
                    greenY: parseInt(document.getElementById('greenY').value),
                    blueX: parseInt(document.getElementById('blueX').value),
                    blueY: parseInt(document.getElementById('blueY').value),
                    useSharedMap: document.getElementById('useSharedMap').checked
                };
            };

            // Define apply function
            window.applyToolPreset = function(params) {
                if (params.patternType !== undefined) {
                    document.getElementById('patternType').value = params.patternType;
                }
                if (params.patternScale !== undefined) {
                    document.getElementById('patternScale').value = params.patternScale;
                    document.getElementById('patternScaleValue').textContent = params.patternScale;
                }
                if (params.patternFreq !== undefined) {
                    document.getElementById('patternFreq').value = params.patternFreq;
                    document.getElementById('patternFreqValue').textContent = params.patternFreq.toFixed(1);
                }
                if (params.patternAmp !== undefined) {
                    document.getElementById('patternAmp').value = params.patternAmp;
                    document.getElementById('patternAmpValue').textContent = params.patternAmp.toFixed(2);
                }
                if (params.patternRot !== undefined) {
                    document.getElementById('patternRot').value = params.patternRot;
                    document.getElementById('patternRotValue').textContent = params.patternRot + '°';
                }
                if (params.patternFalloff !== undefined) {
                    document.getElementById('patternFalloff').value = params.patternFalloff;
                    document.getElementById('patternFalloffValue').textContent = params.patternFalloff.toFixed(2);
                }
                if (params.xStrength !== undefined) {
                    document.getElementById('xStrength').value = params.xStrength;
                    document.getElementById('xStrengthValue').textContent = params.xStrength;
                }
                if (params.yStrength !== undefined) {
                    document.getElementById('yStrength').value = params.yStrength;
                    document.getElementById('yStrengthValue').textContent = params.yStrength;
                }
                if (params.threshold !== undefined) {
                    document.getElementById('threshold').value = params.threshold;
                    document.getElementById('thresholdValue').textContent = params.threshold;
                }
                if (params.edgeMode !== undefined) {
                    document.getElementById('edgeMode').value = params.edgeMode;
                }
                if (params.blur !== undefined) {
                    document.getElementById('blur').value = params.blur;
                    document.getElementById('blurValue').textContent = params.blur;
                }
                if (params.gamma !== undefined) {
                    document.getElementById('gamma').value = params.gamma;
                    document.getElementById('gammaValue').textContent = params.gamma.toFixed(1);
                }
                if (params.contrast !== undefined) {
                    document.getElementById('contrast').value = params.contrast;
                    document.getElementById('contrastValue').textContent = params.contrast;
                }
                if (params.blackPoint !== undefined) {
                    document.getElementById('blackPoint').value = params.blackPoint;
                    document.getElementById('blackPointValue').textContent = params.blackPoint;
                }
                if (params.whitePoint !== undefined) {
                    document.getElementById('whitePoint').value = params.whitePoint;
                    document.getElementById('whitePointValue').textContent = params.whitePoint;
                }
                if (params.saturation !== undefined) {
                    document.getElementById('saturation').value = params.saturation;
                    document.getElementById('saturationValue').textContent = params.saturation;
                }
                if (params.hue !== undefined) {
                    document.getElementById('hue').value = params.hue;
                    document.getElementById('hueValue').textContent = params.hue + '°';
                }
                if (params.blendMode !== undefined) {
                    document.getElementById('blendMode').value = params.blendMode;
                }
                if (params.opacity !== undefined) {
                    document.getElementById('opacity').value = params.opacity;
                    document.getElementById('opacityValue').textContent = params.opacity + '%';
                }
                if (params.enableChromatic !== undefined) {
                    document.getElementById('enableChromatic').checked = params.enableChromatic;
                }
                if (params.redX !== undefined) {
                    document.getElementById('redX').value = params.redX;
                    document.getElementById('redXValue').textContent = params.redX;
                }
                if (params.redY !== undefined) {
                    document.getElementById('redY').value = params.redY;
                    document.getElementById('redYValue').textContent = params.redY;
                }
                if (params.greenX !== undefined) {
                    document.getElementById('greenX').value = params.greenX;
                    document.getElementById('greenXValue').textContent = params.greenX;
                }
                if (params.greenY !== undefined) {
                    document.getElementById('greenY').value = params.greenY;
                    document.getElementById('greenYValue').textContent = params.greenY;
                }
                if (params.blueX !== undefined) {
                    document.getElementById('blueX').value = params.blueX;
                    document.getElementById('blueXValue').textContent = params.blueX;
                }
                if (params.blueY !== undefined) {
                    document.getElementById('blueY').value = params.blueY;
                    document.getElementById('blueYValue').textContent = params.blueY;
                }
                if (params.useSharedMap !== undefined) {
                    document.getElementById('useSharedMap').checked = params.useSharedMap;
                }

                // Re-render with new params
                if (sourceImage) {
                    regeneratePattern();
                    render();
                }
            };
        }
    </script>
</body>
</html>
