<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Visualizer (Animated) - YS Studio Artifacts</title>
    <link rel="stylesheet" href="../../shared/preset-ui.css">
    <style>
        /* Font Imports */
        @font-face {
            font-family: 'Basis Grotesque';
            src: url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.woff2') format('woff2'),
                 url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.woff') format('woff'),
                 url('../../fonts/Basis Grotesque/basis-grotesque-regular-pro.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kalice';
            src: url('../../fonts/Kalice/Kalice-Regular-alternative.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kalice';
            src: url('../../fonts/Kalice/Kalice-Italic-alternative.otf') format('opentype');
            font-weight: 400;
            font-style: italic;
            font-display: swap;
        }

        /* YS Studio Design System Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Colors */
            --ys-white: #FFFFFF;
            --ys-black: #000000;
            --ys-red: #FF0000;
            --ys-gray: #D9D9D9;
            --ys-gray-light: #F5F5F5;

            /* Fonts */
            --font-suisse: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-sangbleu: Georgia, 'Times New Roman', serif;
            --font-mono: 'Courier New', monospace;

            /* Spacing */
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 24px;
            --spacing-lg: 40px;
            --spacing-xl: 80px;
        }

        body {
            font-family: var(--font-suisse);
            color: var(--ys-black);
            background: var(--ys-white);
            line-height: 1.5;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header Component */
        .ys-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 57px;
            padding: 24px;
            background: var(--ys-white);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 1000;
            border-bottom: 1px solid var(--ys-black);
        }

        .header-left {
            display: flex;
            gap: 2px;
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            color: var(--ys-black);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }

        .header-left:hover {
            opacity: 0.7;
        }

        .studio-name {
            font-weight: 300;
        }

        .project-type {
            font-style: italic;
        }

        .header-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            font-weight: 300;
        }

        .header-right {
            display: flex;
            gap: 40px;
            font-size: 12px;
            line-height: 24px;
            letter-spacing: 0.24px;
            font-weight: 300;
        }

        .header-right a {
            color: var(--ys-black);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }

        .header-right a:hover {
            opacity: 0.6;
        }

        .header-right a.active {
            font-weight: 500;
        }

        /* Cross Elements */
        .cross-small {
            width: 12px;
            height: 12px;
            position: relative;
            color: var(--ys-black);
            display: inline-block;
        }

        .cross-small::before,
        .cross-small::after {
            content: '';
            position: absolute;
            background: currentColor;
        }

        .cross-small::before {
            width: 1px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .cross-small::after {
            width: 100%;
            height: 1px;
            top: 50%;
            transform: translateY(-50%);
        }

        .cross-large {
            width: 40px;
            height: 40px;
            position: relative;
            color: var(--ys-red);
            display: inline-block;
        }

        .cross-large::before,
        .cross-large::after {
            content: '';
            position: absolute;
            background: currentColor;
        }

        .cross-large::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .cross-large::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Main Container */
        .ys-container {
            width: 100%;
            max-width: 1920px;
            margin: 0 auto;
            padding: 80px 24px 24px;
            min-height: 100vh;
        }

        /* Title Section */
        .title-section {
            margin-bottom: 20px;
            position: relative;
        }

        .type-display-xl {
            font-family: var(--font-sangbleu);
            font-size: 120px;
            line-height: 120px;
            letter-spacing: -4.8px;
            font-style: italic;
            text-transform: lowercase;
            font-weight: 400;
            margin: 20px 0;
        }

        /* Cross Wrapper Component */
        .ys-cross-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            width: 100%;
            background: var(--ys-white);
            margin-bottom: 24px;
        }

        .cross-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: 12px;
            position: relative;
        }

        .wrapper-content {
            flex: 1;
            padding: 16px;
        }

        .control-panel .wrapper-content {
            padding: 12px;
        }

        /* Tool Container */
        .tool-container {
            display: flex;
            height: calc(100vh - 200px);
            gap: 24px;
        }

        /* Left Panel - Controls */
        .controls-panel {
            width: 320px;
            background: var(--ys-white);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .controls-panel .ys-cross-wrapper {
            margin-bottom: 0;
            height: 100%;
        }

        .controls-panel .wrapper-content {
            padding: var(--spacing-md);
            overflow-y: auto;
        }

        /* Right Panel - Canvas */
        .canvas-panel {
            flex: 1;
            background: var(--ys-white);
            position: relative;
            overflow: hidden;
        }

        .canvas-panel .ys-cross-wrapper {
            margin-bottom: 0;
            height: 100%;
        }

        .canvas-panel .wrapper-content {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-lg);
            height: 100%;
        }

        /* Control Sections */
        .control-section {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--ys-gray);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        /* Form Elements */
        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 10px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            font-weight: 400;
            line-height: 1.2;
            margin-bottom: 4px;
        }

        textarea {
            width: 100%;
            padding: 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            resize: vertical;
            min-height: 80px;
        }

        select {
            width: 100%;
            padding: 6px;
            font-size: 12px;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            cursor: pointer;
            font-family: var(--font-suisse);
        }

        /* Custom Slider */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="range"] {
            flex: 1;
            height: 1px;
            background: var(--ys-black);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
            border: none;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--ys-black);
            cursor: pointer;
            border: none;
        }

        input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 1px;
            cursor: pointer;
            background: var(--ys-black);
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 1px;
            cursor: pointer;
            background: var(--ys-black);
        }

        .slider-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            font-family: var(--font-mono);
        }

        /* Toggle Buttons */
        .toggle-group {
            display: flex;
            gap: 0;
            border: 1px solid var(--ys-black);
            overflow: hidden;
        }

        .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--ys-white);
            border: none;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-right: 1px solid var(--ys-black);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 400;
        }

        .toggle-btn:last-child {
            border-right: none;
        }

        .toggle-btn.active {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .toggle-btn:hover:not(.active) {
            background: var(--ys-gray-light);
        }

        /* Action Buttons */
        .btn {
            width: 100%;
            padding: 10px 16px;
            background: var(--ys-white);
            color: var(--ys-black);
            border: 1px solid var(--ys-black);
            font-size: 11px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .btn-primary {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .btn-primary:hover {
            background: var(--ys-white);
            color: var(--ys-black);
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        /* Playback Controls */
        .playback-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .play-btn {
            padding: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .play-btn:hover {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        .play-btn.playing {
            background: var(--ys-black);
            color: var(--ys-white);
        }

        /* Canvas Styling */
        #visualCanvas {
            background: var(--ys-white);
            border: 1px solid var(--ys-black);
            max-width: 100%;
            max-height: 100%;
            display: block;
            cursor: crosshair;
        }

        /* Checkbox */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        input[type="checkbox"] {
            width: 12px;
            height: 12px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            border: 1px solid var(--ys-black);
            background: var(--ys-white);
            position: relative;
        }

        input[type="checkbox"]:checked {
            background: var(--ys-black);
        }

        input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            color: var(--ys-white);
            font-size: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            line-height: 1;
        }

        .checkbox-label {
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Character Counter */
        .char-counter {
            text-align: right;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* FPS Counter */
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: var(--ys-white);
            padding: 4px 8px;
            font-family: var(--font-mono);
            font-size: 11px;
            z-index: 100;
        }

        /* Recording Indicator Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #recordingDot {
            animation: pulse 1s infinite;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .controls-panel {
                width: 320px;
            }
        }

        @media (max-width: 768px) {
            .type-display-xl {
                font-size: 60px;
                line-height: 60px;
            }

            .tool-container {
                flex-direction: column;
            }

            .controls-panel {
                width: 100%;
                max-height: 50vh;
                border-right: 1px solid var(--ys-black);
            }

            .header-center {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .header-right {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- YS Header -->
    <header class="ys-header">
        <a href="/" class="header-left">
            <span class="studio-name">YAMBO STUDIO</span>
            <span>—</span>
            <span class="project-type">Artifacts</span>
        </a>
        <div class="header-center">Text Visualizer (Animated)</div>
        <nav class="header-right">
            <a href="/about.html">About</a>
            <a href="/" class="active">Tools</a>
        </nav>
    </header>

    <!-- Main Container -->
    <div class="ys-container">
        <!-- Title Section -->
        <div class="title-section">
            <h1 class="type-display-xl">text visualizer</h1>
        </div>

        <!-- Tool Container -->
        <div class="tool-container">
        <!-- Left Panel: Controls -->
        <div class="controls-panel">
            <div class="ys-cross-wrapper">
                <div class="cross-row">
                    <span class="cross-small"></span>
                    <span class="cross-small"></span>
                </div>
                <div class="wrapper-content">
            <!-- Preset Section -->
            <div id="presetContainer"></div>

            <!-- Text Input Section -->
            <div class="control-section">
                <h3 class="section-title">Text Input</h3>
                <div class="control-group">
                    <textarea id="textInput" placeholder="Enter your text here...">YAMBO STUDIO</textarea>
                    <div class="char-counter"><span id="charCount">12</span> characters</div>
                </div>
                <div class="control-group">
                    <label>Mode</label>
                    <div class="toggle-group">
                        <button class="toggle-btn" data-mode="words">Words</button>
                        <button class="toggle-btn active" data-mode="characters">Characters</button>
                    </div>
                </div>
            </div>

            <!-- Animation Control Section -->
            <div class="control-section">
                <h3 class="section-title">Animation</h3>
                <div class="playback-controls">
                    <button id="playBtn" class="play-btn playing">
                        <span id="playIcon">⏸</span>
                    </button>
                    <button id="resetBtn" class="btn">Reset</button>
                </div>

                <div class="control-group">
                    <label>Speed: <span id="speedValue">1.0</span>x</label>
                    <div class="slider-container">
                        <input type="range" id="animSpeed" min="0.1" max="3" step="0.1" value="1">
                        <span class="slider-value">1.0</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Effects</label>
                    <div class="checkbox-container">
                        <input type="checkbox" id="effectOscillate" checked>
                        <label for="effectOscillate" class="checkbox-label">Oscillate</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="effectRotate" checked>
                        <label for="effectRotate" class="checkbox-label">Rotate</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="effectBreathe">
                        <label for="effectBreathe" class="checkbox-label">Breathe (Scale)</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="effectWave">
                        <label for="effectWave" class="checkbox-label">Wave</label>
                    </div>
                </div>

                <div class="control-group">
                    <label>Phase X: <span id="phaseXValue">30</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="phaseX" min="0" max="100" value="30">
                        <span class="slider-value">30</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Phase Y: <span id="phaseYValue">30</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="phaseY" min="0" max="100" value="30">
                        <span class="slider-value">30</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Rotation Amount: <span id="rotAmountValue">180</span>°</label>
                    <div class="slider-container">
                        <input type="range" id="rotAmount" min="0" max="360" value="180">
                        <span class="slider-value">180</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Wave Frequency: <span id="waveFreqValue">0.5</span></label>
                    <div class="slider-container">
                        <input type="range" id="waveFreq" min="0.1" max="2" step="0.1" value="0.5">
                        <span class="slider-value">0.5</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Stagger: <span id="staggerValue">0.1</span></label>
                    <div class="slider-container">
                        <input type="range" id="stagger" min="0" max="0.5" step="0.01" value="0.1">
                        <span class="slider-value">0.1</span>
                    </div>
                </div>
            </div>

            <!-- Advanced Mode Section -->
            <div class="control-section">
                <h3 class="section-title">Advanced Mode</h3>
                <div class="control-group">
                    <div class="checkbox-container">
                        <input type="checkbox" id="advancedMode">
                        <label for="advancedMode" class="checkbox-label"><strong>Enable Advanced Mode</strong></label>
                    </div>
                </div>

                <div id="advancedControls" style="display: none;">
                    <!-- ORGANIC DISTRIBUTION SYSTEM -->
                    <div class="control-group">
                        <div class="checkbox-container">
                            <input type="checkbox" id="organicEnabled">
                            <label for="organicEnabled" class="checkbox-label"><strong>Enable Organic Distribution</strong></label>
                        </div>
                    </div>

                    <div id="organicControls" style="display: none;">
                        <div class="control-group">
                            <label>Repetition Type</label>
                            <select id="repetitionType">
                                <option value="phrase">Repeat Phrase</option>
                                <option value="words">Repeat Words</option>
                                <option value="letters">Repeat Letters</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label>Layout</label>
                            <select id="organicLayout">
                                <option value="vertical">Vertical</option>
                                <option value="horizontal">Horizontal</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label>Interval: <span id="intervalValue">10</span>px</label>
                            <div class="slider-container">
                                <input type="range" id="interval" min="0" max="50" value="10">
                                <span class="slider-value">10</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Distribution Order</label>
                            <select id="distributionOrder">
                                <option value="sequential">Sequential</option>
                                <option value="random">Random</option>
                                <option value="reverse">Reverse</option>
                                <option value="ping-pong">Ping-Pong</option>
                            </select>
                        </div>
                    </div>

                    <!-- COMPOSABLE INFLUENCES (work with any base) -->
                    <div class="control-group" style="margin-top: 20px;">
                        <label style="font-size: 11px; opacity: 0.8;">POSITION INFLUENCE (adds to any pattern)</label>
                    </div>

                    <div class="control-group">
                        <label>Position Mode</label>
                        <select id="positionMode">
                            <option value="none">None</option>
                            <option value="noise">Noise (Organic)</option>
                            <option value="sin">Sine Wave</option>
                            <option value="doublesin">Double Sine</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Amplitude: <span id="posAmplitudeValue">50</span></label>
                        <div class="slider-container">
                            <input type="range" id="posAmplitude" min="0" max="100" value="50">
                            <span class="slider-value">50</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Amplitude Distribution</label>
                        <select id="amplitudeMode">
                            <option value="uniform">Uniform</option>
                            <option value="center">Center Focus</option>
                            <option value="edge">Edge Focus</option>
                            <option value="side-left">Left Side</option>
                            <option value="side-right">Right Side</option>
                        </select>
                    </div>

                    <div class="control-group" style="margin-top: 20px;">
                        <label style="font-size: 11px; opacity: 0.8;">SCALE INFLUENCE (multiplies any scale)</label>
                    </div>

                    <div class="control-group">
                        <label>Scale Mode</label>
                        <select id="scaleMode">
                            <option value="none">None</option>
                            <option value="position">By Position</option>
                            <option value="sin">Sine Wave</option>
                            <option value="doublesin">Double Sine</option>
                            <option value="noise">Noise</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Scale Min: <span id="scaleMinValue">0.2</span></label>
                        <div class="slider-container">
                            <input type="range" id="scaleInfluenceMin" min="0.1" max="1" step="0.1" value="0.2">
                            <span class="slider-value">0.2</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Scale Max: <span id="scaleMaxValue">1.0</span></label>
                        <div class="slider-container">
                            <input type="range" id="scaleInfluenceMax" min="1" max="3" step="0.1" value="1">
                            <span class="slider-value">1.0</span>
                        </div>
                    </div>

                    <!-- LEGACY CONTROLS (still work!) -->
                    <div class="control-group" style="margin-top: 20px;">
                        <label style="font-size: 11px; opacity: 0.8;">LEGACY ADVANCED CONTROLS</label>
                    </div>

                    <div class="control-group">
                        <label>Repetitions: <span id="repetitionsValue">1</span>x</label>
                        <div class="slider-container">
                            <input type="range" id="repetitions" min="1" max="200" value="1">
                            <span class="slider-value">1</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Fragment Mode</label>
                        <select id="fragmentMode">
                            <option value="phrase">Full Phrase</option>
                            <option value="words">Words</option>
                            <option value="characters">Characters</option>
                            <option value="mixed">Mixed</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Density: <span id="densityValue">1.0</span></label>
                        <div class="slider-container">
                            <input type="range" id="density" min="0.1" max="2" step="0.1" value="1">
                            <span class="slider-value">1.0</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Overlap: <span id="overlapValue">0</span></label>
                        <div class="slider-container">
                            <input type="range" id="overlap" min="0" max="1" step="0.05" value="0">
                            <span class="slider-value">0</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Size Variation: <span id="sizeVariationValue">0</span></label>
                        <div class="slider-container">
                            <input type="range" id="sizeVariation" min="0" max="1" step="0.05" value="0">
                            <span class="slider-value">0</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Opacity Variation: <span id="opacityVariationValue">0</span></label>
                        <div class="slider-container">
                            <input type="range" id="opacityVariation" min="0" max="1" step="0.05" value="0">
                            <span class="slider-value">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Typography Section -->
            <div class="control-section">
                <h3 class="section-title">Typography</h3>
                <div class="control-group">
                    <label>Font</label>
                    <select id="fontSelect">
                        <option value="Basis Grotesque">Basis Grotesque</option>
                        <option value="Kalice">Kalice</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Arial">Arial</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Impact">Impact</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Garamond">Garamond</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Size: <span id="sizeValue">48</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="fontSize" min="10" max="200" value="48">
                        <span class="slider-value">48</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Weight: <span id="weightValue">400</span></label>
                    <div class="slider-container">
                        <input type="range" id="fontWeight" min="100" max="900" step="100" value="400">
                        <span class="slider-value">400</span>
                    </div>
                </div>
            </div>

            <!-- Pattern Section -->
            <div class="control-section">
                <h3 class="section-title">Pattern</h3>
                <div class="control-group">
                    <label>Type</label>
                    <select id="patternSelect">
                        <option value="grid">Grid</option>
                        <option value="circle">Circle</option>
                        <option value="wave">Wave</option>
                        <option value="spiral">Spiral</option>
                        <option value="random">Random</option>
                        <option value="orbital">Orbital</option>
                    </select>
                </div>

                <!-- Pattern-specific parameters will be added dynamically -->
                <div id="patternParams"></div>
            </div>

            <!-- Export Section -->
            <div class="control-section">
                <h3 class="section-title">Export</h3>

                <!-- Export Type Toggle -->
                <div class="control-group">
                    <label>Export Type</label>
                    <div class="toggle-group">
                        <button class="toggle-btn active" data-export="frame">Frame</button>
                        <button class="toggle-btn" data-export="animation">Animation</button>
                    </div>
                </div>

                <!-- Frame Export Controls -->
                <div id="frameExportControls">
                    <div class="control-group">
                        <button id="exportBtn" class="btn btn-primary">Export Frame (PNG) ↓</button>
                    </div>
                </div>

                <!-- Animation Export Controls -->
                <div id="animationExportControls" style="display: none;">
                    <div class="control-group">
                        <label>Format</label>
                        <div class="toggle-group">
                            <button class="toggle-btn active" data-format="mp4">MP4</button>
                            <button class="toggle-btn" data-format="gif">GIF</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Duration Mode</label>
                        <div class="toggle-group">
                            <button class="toggle-btn active" data-duration="auto">Auto Loop</button>
                            <button class="toggle-btn" data-duration="custom">Custom</button>
                        </div>
                    </div>

                    <div id="customDurationControls" style="display: none;">
                        <div class="control-group">
                            <label>Duration: <span id="customDurationValue">5</span>s</label>
                            <div class="slider-container">
                                <input type="range" id="customDuration" min="1" max="30" value="5">
                                <span class="slider-value">5</span>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <div id="loopInfo" style="font-size: 11px; opacity: 0.7; margin-bottom: 8px;">
                            Loop duration: <strong><span id="autoLoopDuration">6.28</span>s</strong>
                        </div>
                    </div>

                    <div class="control-group">
                        <button id="exportAnimationBtn" class="btn btn-primary">
                            <span id="exportAnimationText">Export Animation ↓</span>
                        </button>
                    </div>

                    <!-- Recording Indicator -->
                    <div id="recordingIndicator" style="display: none;">
                        <div style="padding: 12px; border: 1px solid var(--ys-red); background: rgba(255,0,0,0.05); margin-top: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <div id="recordingDot" style="width: 8px; height: 8px; background: var(--ys-red); border-radius: 50%;"></div>
                                <span style="font-size: 11px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px;">RECORDING</span>
                            </div>
                            <div style="font-size: 11px; font-family: var(--font-mono);">
                                Progress: <span id="recordingProgress">0</span>%
                            </div>
                        </div>
                    </div>
                </div>
            </div>
                </div>
                <div class="cross-row">
                    <span class="cross-small"></span>
                    <span class="cross-small"></span>
                </div>
            </div>
        </div>

        <!-- Right Panel: Canvas -->
        <div class="canvas-panel">
            <div class="ys-cross-wrapper">
                <div class="cross-row">
                    <span class="cross-small"></span>
                    <span class="cross-small"></span>
                </div>
                <div class="wrapper-content">
            <div class="fps-counter">FPS: <span id="fpsValue">60</span></div>
            <canvas id="visualCanvas" width="1920" height="1080"></canvas>
                </div>
                <div class="cross-row">
                    <span class="cross-small"></span>
                    <span class="cross-small"></span>
                </div>
            </div>
        </div>
    </div>
    </div>

    <!-- GIF.js Library for GIF Export (Local) -->
    <script src="../../shared/gif.js"></script>

    <script>
        // Animated Text Visualizer Engine
        class AnimatedTextEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');

                // Core properties
                this.text = 'YAMBO STUDIO';
                this.mode = 'characters';
                this.pattern = 'grid';
                this.isPlaying = true;

                // Animation properties
                this.time = 0;
                this.deltaTime = 0;
                this.lastTime = 0;
                this.animationSpeed = 1.0;

                // Typography
                this.font = {
                    family: 'Helvetica',
                    size: 48,
                    weight: 400
                };

                // Animation parameters
                this.animParams = {
                    phaseX: 30,
                    phaseY: 30,
                    rotationAmount: 180,
                    waveFrequency: 0.5,
                    stagger: 0.1,
                    breatheAmount: 0.2,
                    orbitRadius: 100
                };

                // Advanced mode parameters
                this.advancedMode = false;
                this.advancedParams = {
                    repetitions: 1,
                    fragmentMode: 'phrase',
                    density: 1.0,
                    overlap: 0,
                    sizeVariation: 0,
                    opacityVariation: 0
                };

                // Organic distribution parameters (v3 - composable system)
                this.organicParams = {
                    enabled: false,
                    repetitionType: 'phrase', // 'phrase', 'words', 'letters'
                    interval: 10,             // Base spacing between repetitions
                    layout: 'vertical'        // 'vertical', 'horizontal'
                };

                // Position influence (composable - adds to base position)
                this.positionInfluence = {
                    mode: 'noise',            // 'none', 'noise', 'sin', 'doublesin'
                    amplitude: 50,            // 0-100 strength
                    amplitudeMode: 'uniform', // 'uniform', 'center', 'edge', 'side-left', 'side-right'
                    noise: {
                        x: 0.3,               // Noise frequency X
                        y: 1.0,               // Noise frequency Y
                        speed: 0.5,           // Animation speed
                        seed: Math.floor(Math.random() * 10000)
                    },
                    sin: {
                        x: 1,                 // Sine frequency X
                        y: 1.5,               // Sine frequency Y
                        cycle: 2              // Wave cycles
                    }
                };

                // Scale influence (composable - multiplies with base scale)
                this.scaleInfluence = {
                    mode: 'none',             // 'none', 'position', 'sin', 'doublesin', 'noise'
                    min: 0.2,                 // Minimum scale multiplier
                    max: 1.0,                 // Maximum scale multiplier
                    easing: 'linear'          // Easing function
                };

                // Distribution control
                this.distribution = {
                    order: 'sequential'       // 'sequential', 'random', 'reverse', 'ping-pong'
                };

                // Effects toggles
                this.effects = {
                    oscillate: true,
                    rotate: true,
                    breathe: false,
                    wave: false
                };

                // Pattern-specific params
                this.patternParams = {
                    cols: 5,
                    gapX: 80,
                    gapY: 80,
                    radius: 200,
                    spiralGrowth: 15
                };

                // Performance tracking
                this.fps = 60;
                this.frameCount = 0;
                this.fpsTime = 0;

                // Pre-calculated positions
                this.basePositions = [];

                // Recording state
                this.isRecording = false;
                this.recordingStartTime = 0;
                this.recordingDuration = 0;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.gifEncoder = null;
                this.recordingFrames = [];
                this.recordingProgressCallback = null;

                this.setupCanvas();
                this.calculateBasePositions();
                this.animate();
            }

            calculateLoopDuration() {
                // Calculate the perfect loop duration based on active animation effects
                // Each effect uses periodic functions (sin/cos) with different frequencies

                let periods = [];

                // Base oscillation period: sin(t) has period 2π
                periods.push(2 * Math.PI);

                // Rotation effect: sin(0.5t) has period 4π
                if (this.effects.rotate) {
                    periods.push(4 * Math.PI);
                }

                // Breathe effect: sin(2t) has period π
                if (this.effects.breathe) {
                    periods.push(Math.PI);
                }

                // Wave effect: sin(freq * t) has period 2π/freq
                if (this.effects.wave) {
                    periods.push(2 * Math.PI / this.animParams.waveFrequency);
                }

                // Pattern-specific periods
                if (this.pattern === 'circle' || this.pattern === 'orbital') {
                    // Orbital motion: baseAngle + time * 0.2 or 0.3
                    // For perfect loop, need time * speed = 2π
                    periods.push(2 * Math.PI / 0.3); // Using 0.3 as it's the fastest
                }

                if (this.pattern === 'spiral') {
                    // Spiral: angle + time * 0.3
                    periods.push(2 * Math.PI / 0.3);
                    // Growth pulse: sin(time * 0.5)
                    periods.push(2 * Math.PI / 0.5);
                }

                // Find the longest period (this ensures all effects complete at least one full cycle)
                const maxPeriod = Math.max(...periods);

                // Convert to seconds, accounting for animation speed
                // Higher animation speed = shorter real-world duration
                const durationSeconds = maxPeriod / this.animationSpeed;

                return durationSeconds;
            }

            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();

                this.canvas.width = 1920;
                this.canvas.height = 1080;

                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';

                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
            }

            getElements() {
                let base;

                // Get base elements based on mode
                if (this.mode === 'words') {
                    base = this.text.trim().split(/\s+/).filter(w => w.length > 0);
                } else {
                    base = this.text.split('');
                }

                // Apply advanced mode multiplication
                if (this.advancedMode && this.advancedParams.repetitions > 1) {
                    let elements = [];

                    for (let i = 0; i < this.advancedParams.repetitions; i++) {
                        if (this.advancedParams.fragmentMode === 'phrase') {
                            // Repeat full phrase
                            elements.push(...base);
                        } else if (this.advancedParams.fragmentMode === 'words') {
                            // Fragment into words even if in char mode
                            const words = this.text.trim().split(/\s+/);
                            elements.push(...words);
                        } else if (this.advancedParams.fragmentMode === 'characters') {
                            // Fragment into characters even if in word mode
                            elements.push(...this.text.split(''));
                        } else if (this.advancedParams.fragmentMode === 'mixed') {
                            // Mix words and characters
                            if (i % 2 === 0) {
                                elements.push(...this.text.trim().split(/\s+/));
                            } else {
                                elements.push(...this.text.split(''));
                            }
                        }
                    }

                    return elements;
                }

                return base;
            }

            calculateBasePositions() {
                const elements = this.getElements();
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // Check for organic distribution system (composable with patterns)
                if (this.advancedMode && this.organicParams.enabled) {
                    this.basePositions = this.calculateOrganicDistribution(centerX, centerY);
                    return;
                }

                // Use existing pattern system
                switch(this.pattern) {
                    case 'grid':
                        this.basePositions = this.calculateGridPositions(elements, centerX, centerY);
                        break;
                    case 'circle':
                        this.basePositions = this.calculateCirclePositions(elements, centerX, centerY);
                        break;
                    case 'wave':
                        this.basePositions = this.calculateWavePositions(elements, centerX, centerY);
                        break;
                    case 'spiral':
                        this.basePositions = this.calculateSpiralPositions(elements, centerX, centerY);
                        break;
                    case 'random':
                        this.basePositions = this.calculateRandomPositions(elements, centerX, centerY);
                        break;
                    case 'orbital':
                        this.basePositions = this.calculateOrbitalPositions(elements, centerX, centerY);
                        break;
                    default:
                        this.basePositions = this.calculateGridPositions(elements, centerX, centerY);
                }
            }

            calculateGridPositions(elements, centerX, centerY) {
                const positions = [];

                // Auto-adjust columns for large element counts
                let cols = this.patternParams.cols;
                if (this.advancedMode && elements.length > 25) {
                    cols = Math.ceil(Math.sqrt(elements.length * 1.2));
                }

                const rows = Math.ceil(elements.length / cols);

                // Apply density to gaps
                const gapX = this.patternParams.gapX * this.advancedParams.density;
                const gapY = this.patternParams.gapY * this.advancedParams.density;

                // Apply overlap reduction
                const effectiveGapX = gapX * (1 - this.advancedParams.overlap * 0.7);
                const effectiveGapY = gapY * (1 - this.advancedParams.overlap * 0.7);

                const startX = centerX - ((cols - 1) * effectiveGapX) / 2;
                const startY = centerY - ((rows - 1) * effectiveGapY) / 2;

                elements.forEach((text, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    positions.push({
                        text,
                        baseX: startX + col * effectiveGapX,
                        baseY: startY + row * effectiveGapY,
                        index: i,
                        // Add variation seeds for advanced mode
                        sizeVar: Math.random(),
                        opacityVar: Math.random()
                    });
                });

                return positions;
            }

            calculateCirclePositions(elements, centerX, centerY) {
                const positions = [];
                const angleStep = (2 * Math.PI) / elements.length;

                // Auto-scale radius for large element counts and apply density
                let radius = this.patternParams.radius;
                if (this.advancedMode && elements.length > 20) {
                    radius = radius * Math.sqrt(elements.length / 12);
                }
                radius = radius * this.advancedParams.density;

                elements.forEach((text, i) => {
                    const angle = i * angleStep - Math.PI / 2;
                    positions.push({
                        text,
                        baseX: centerX + radius * Math.cos(angle),
                        baseY: centerY + radius * Math.sin(angle),
                        baseAngle: angle,
                        index: i,
                        sizeVar: Math.random(),
                        opacityVar: Math.random()
                    });
                });

                return positions;
            }

            calculateWavePositions(elements, centerX, centerY) {
                const positions = [];
                const width = this.canvas.width * 0.8;
                const startX = centerX - width / 2;
                const spacing = width / (elements.length - 1 || 1);

                elements.forEach((text, i) => {
                    positions.push({
                        text,
                        baseX: startX + i * spacing,
                        baseY: centerY,
                        index: i
                    });
                });

                return positions;
            }

            calculateSpiralPositions(elements, centerX, centerY) {
                const positions = [];
                const growth = this.patternParams.spiralGrowth;

                elements.forEach((text, i) => {
                    const angle = i * 0.5;
                    const radius = growth * angle;

                    positions.push({
                        text,
                        baseX: centerX + radius * Math.cos(angle),
                        baseY: centerY + radius * Math.sin(angle),
                        baseAngle: angle,
                        index: i
                    });
                });

                return positions;
            }

            calculateRandomPositions(elements, centerX, centerY) {
                const positions = [];
                const spreadX = this.canvas.width * 0.6;
                const spreadY = this.canvas.height * 0.6;

                // Seeded random for consistency
                let seed = 12345;
                const random = () => {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };

                elements.forEach((text, i) => {
                    positions.push({
                        text,
                        baseX: centerX + (random() - 0.5) * spreadX,
                        baseY: centerY + (random() - 0.5) * spreadY,
                        randomSeed: random(),
                        index: i
                    });
                });

                return positions;
            }

            calculateOrbitalPositions(elements, centerX, centerY) {
                const positions = [];
                const orbits = 3; // Number of orbital rings
                const perOrbit = Math.ceil(elements.length / orbits);

                elements.forEach((text, i) => {
                    const orbit = Math.floor(i / perOrbit);
                    const indexInOrbit = i % perOrbit;
                    const angleStep = (2 * Math.PI) / perOrbit;
                    const radius = 100 + orbit * 80;
                    const angle = indexInOrbit * angleStep;

                    positions.push({
                        text,
                        baseX: centerX + radius * Math.cos(angle),
                        baseY: centerY + radius * Math.sin(angle),
                        orbit: orbit,
                        orbitRadius: radius,
                        baseAngle: angle,
                        index: i
                    });
                });

                return positions;
            }

            // ORGANIC DISTRIBUTION SYSTEM (v3)

            // Simple 2D noise generator (multiple sine waves for organic feel)
            simpleNoise2D(x, y, seed = 0) {
                const X = x + seed;
                const Y = y + seed;

                // Multiple frequencies for organic feel
                const n1 = Math.sin(X * 12.9898 + Y * 78.233) * 43758.5453;
                const n2 = Math.sin(X * 93.9898 + Y * 47.233) * 27183.5453;
                const n3 = Math.sin(X * 43.9898 + Y * 12.233) * 81724.5453;

                // Combine and normalize to -1 to 1
                return ((n1 % 1) + (n2 % 1) + (n3 % 1)) / 3 * 2 - 1;
            }

            // Smooth noise using bilinear interpolation
            smoothNoise(x, y, scale, seed) {
                const sx = x * scale;
                const sy = y * scale;

                const x0 = Math.floor(sx);
                const x1 = x0 + 1;
                const y0 = Math.floor(sy);
                const y1 = y0 + 1;

                const fx = sx - x0;
                const fy = sy - y0;

                // Sample 4 corners
                const n00 = this.simpleNoise2D(x0, y0, seed);
                const n10 = this.simpleNoise2D(x1, y0, seed);
                const n01 = this.simpleNoise2D(x0, y1, seed);
                const n11 = this.simpleNoise2D(x1, y1, seed);

                // Bilinear interpolation
                const nx0 = n00 * (1 - fx) + n10 * fx;
                const nx1 = n01 * (1 - fx) + n11 * fx;

                return nx0 * (1 - fy) + nx1 * fy;
            }

            // Calculate amplitude factor based on position and amplitude mode
            getAmplitudeFactor(normalizedPos, canvasSize, mode) {
                const x = normalizedPos.x;
                const y = normalizedPos.y;
                const centerDist = Math.sqrt(Math.pow(x - 0.5, 2) + Math.pow(y - 0.5, 2)) * 2;

                switch(mode) {
                    case 'uniform':
                        return 1.0;

                    case 'center':
                        // Stronger in center, weaker at edges
                        return 1.0 - centerDist;

                    case 'edge':
                        // Stronger at edges, weaker in center
                        return centerDist;

                    case 'side-left':
                        // Stronger on left, weaker on right
                        return 1.0 - x;

                    case 'side-right':
                        // Stronger on right, weaker on left
                        return x;

                    default:
                        return 1.0;
                }
            }

            // Main organic distribution calculation
            calculateOrganicDistribution(centerX, centerY) {
                const positions = [];
                const reps = this.advancedParams.repetitions;
                const interval = this.organicParams.interval;
                const layout = this.organicParams.layout;
                const repType = this.organicParams.repetitionType;

                let elements = [];

                // Generate elements based on repetition type
                if (repType === 'phrase') {
                    // Repeat entire phrase
                    for (let i = 0; i < reps; i++) {
                        elements.push({
                            text: this.text,
                            type: 'phrase',
                            repIndex: i
                        });
                    }
                } else if (repType === 'words') {
                    // Repeat words
                    const words = this.text.split(/\s+/).filter(w => w.length > 0);
                    for (let i = 0; i < reps; i++) {
                        words.forEach((word, wordIdx) => {
                            elements.push({
                                text: word,
                                type: 'word',
                                repIndex: i,
                                wordIndex: wordIdx
                            });
                        });
                    }
                } else if (repType === 'letters') {
                    // Repeat individual letters
                    const chars = this.text.replace(/\s+/g, '').split('');
                    for (let i = 0; i < reps; i++) {
                        chars.forEach((char, charIdx) => {
                            elements.push({
                                text: char,
                                type: 'letter',
                                repIndex: i,
                                charIndex: charIdx
                            });
                        });
                    }
                }

                // Apply distribution order
                const orderedElements = this.applyDistributionOrder(elements);

                // Calculate positions based on layout
                if (layout === 'vertical') {
                    orderedElements.forEach((el, idx) => {
                        positions.push({
                            text: el.text,
                            baseX: centerX,
                            baseY: centerY - (orderedElements.length * interval / 2) + idx * interval,
                            index: idx,
                            repIndex: el.repIndex,
                            type: el.type,
                            sizeVar: Math.random(),
                            opacityVar: Math.random(),
                            normalizedX: 0.5,
                            normalizedY: idx / Math.max(orderedElements.length - 1, 1)
                        });
                    });
                } else {
                    // Horizontal
                    orderedElements.forEach((el, idx) => {
                        positions.push({
                            text: el.text,
                            baseX: centerX - (orderedElements.length * interval / 2) + idx * interval,
                            baseY: centerY,
                            index: idx,
                            repIndex: el.repIndex,
                            type: el.type,
                            sizeVar: Math.random(),
                            opacityVar: Math.random(),
                            normalizedX: idx / Math.max(orderedElements.length - 1, 1),
                            normalizedY: 0.5
                        });
                    });
                }

                return positions;
            }

            // Apply distribution ordering
            applyDistributionOrder(elements) {
                const order = this.distribution.order;

                switch(order) {
                    case 'sequential':
                        return elements;

                    case 'reverse':
                        return [...elements].reverse();

                    case 'random':
                        return [...elements].sort(() => Math.random() - 0.5);

                    case 'ping-pong':
                        const result = [];
                        for (let i = 0; i < elements.length; i++) {
                            const pingPongIndex = i % 2 === 0 ? i : elements.length - 1 - i;
                            if (pingPongIndex < elements.length) {
                                result.push(elements[pingPongIndex]);
                            }
                        }
                        return result;

                    default:
                        return elements;
                }
            }

            calculatePathFollowing(centerX, centerY) {
                const positions = [];
                const pathType = this.pathParams.type;
                const pathCount = this.pathParams.count;
                const tangentRot = this.pathParams.tangentRotation;

                const sentence = this.text;
                const chars = sentence.split('');

                for (let pathIdx = 0; pathIdx < pathCount; pathIdx++) {
                    const pathProgress = pathCount > 1 ? pathIdx / (pathCount - 1) : 0;

                    chars.forEach((char, charIdx) => {
                        if (char === ' ') return; // Skip spaces for cleaner paths

                        const t = charIdx / Math.max(chars.length - 1, 1); // 0 to 1 along path
                        const point = this.getPathPoint(pathType, t, pathProgress);
                        const tangent = tangentRot ? this.getPathTangent(pathType, t, pathProgress) : 0;

                        positions.push({
                            text: char,
                            baseX: centerX + point.x,
                            baseY: centerY + point.y,
                            rotation: tangent,
                            pathIndex: pathIdx,
                            index: pathIdx * chars.length + charIdx,
                            sizeVar: Math.random(),
                            opacityVar: Math.random()
                        });
                    });
                }

                return positions;
            }

            getPathPoint(type, t, pathIndex) {
                const startRadius = this.pathParams.startRadius;
                const endRadius = this.pathParams.endRadius;
                const amplitude = this.pathParams.waveAmplitude;
                const frequency = this.pathParams.waveFrequency;

                switch(type) {
                    case 'circle': {
                        const radius = startRadius + pathIndex * 50;
                        const angle = t * Math.PI * 2;
                        return {
                            x: radius * Math.cos(angle - Math.PI / 2),
                            y: radius * Math.sin(angle - Math.PI / 2)
                        };
                    }

                    case 'spiral-arch': {
                        const angle = t * Math.PI * 2 * 3; // 3 turns
                        const radius = startRadius + t * (endRadius - startRadius);
                        return {
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle)
                        };
                    }

                    case 'spiral-log': {
                        const angle = t * Math.PI * 2 * 3;
                        const a = startRadius;
                        const b = 0.15;
                        const radius = a * Math.exp(b * angle);
                        return {
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle)
                        };
                    }

                    case 'wave-sine': {
                        const layerOffset = pathIndex * 80;
                        return {
                            x: (t - 0.5) * 800,
                            y: Math.sin(t * Math.PI * frequency) * amplitude + layerOffset
                        };
                    }

                    case 'lissajous': {
                        const a = 3;
                        const b = 4;
                        const delta = Math.PI / 2;
                        const scale = startRadius + pathIndex * 30;
                        return {
                            x: scale * Math.sin(a * t * Math.PI * 2 + delta),
                            y: scale * Math.sin(b * t * Math.PI * 2)
                        };
                    }

                    default:
                        return { x: 0, y: 0 };
                }
            }

            getPathTangent(type, t, pathIndex) {
                const startRadius = this.pathParams.startRadius;
                const endRadius = this.pathParams.endRadius;
                const frequency = this.pathParams.waveFrequency;

                switch(type) {
                    case 'circle': {
                        const angle = t * Math.PI * 2;
                        return angle; // Tangent is perpendicular to radius
                    }

                    case 'spiral-arch':
                    case 'spiral-log': {
                        const angle = t * Math.PI * 2 * 3;
                        return angle + Math.PI / 2;
                    }

                    case 'wave-sine': {
                        const derivative = Math.cos(t * Math.PI * frequency) * Math.PI * frequency;
                        return Math.atan(derivative);
                    }

                    case 'lissajous': {
                        // Approximate tangent for Lissajous
                        const a = 3;
                        const b = 4;
                        const delta = Math.PI / 2;
                        const dx = a * Math.cos(a * t * Math.PI * 2 + delta);
                        const dy = b * Math.cos(b * t * Math.PI * 2);
                        return Math.atan2(dy, dx);
                    }

                    default:
                        return 0;
                }
            }

            calculateWordExtraction(centerX, centerY) {
                const positions = [];
                const words = this.text.split(' ').filter(w => w.length > 0);
                if (words.length === 0) return positions;

                const pattern = this.wordExtractParams.pattern;
                const density = this.wordExtractParams.density;
                const rotSpread = this.wordExtractParams.rotationSpread * Math.PI / 180;
                const scaleMin = this.wordExtractParams.scaleMin;
                const scaleMax = this.wordExtractParams.scaleMax;
                const opacityMin = this.wordExtractParams.opacityMin;
                const opacityMax = this.wordExtractParams.opacityMax;

                const totalPositions = Math.floor(density);

                for (let i = 0; i < totalPositions; i++) {
                    const progress = i / Math.max(totalPositions - 1, 1);
                    const word = words[i % words.length];

                    const point = this.getWordDistributionPoint(pattern, progress, i, totalPositions);

                    // Calculate variations
                    const rotation = (Math.random() - 0.5) * rotSpread;
                    const scale = scaleMin + Math.random() * (scaleMax - scaleMin);
                    const opacity = opacityMin + Math.random() * (opacityMax - opacityMin);

                    positions.push({
                        text: word,
                        baseX: centerX + point.x,
                        baseY: centerY + point.y,
                        rotation: rotation,
                        scale: scale,
                        opacity: opacity,
                        wordIndex: i % words.length,
                        index: i,
                        sizeVar: Math.random(),
                        opacityVar: Math.random()
                    });
                }

                return positions;
            }

            getWordDistributionPoint(pattern, progress, index, total) {
                switch(pattern) {
                    case 'radial-burst': {
                        // Golden angle distribution for even spacing
                        const goldenAngle = 137.5 * Math.PI / 180;
                        const angle = index * goldenAngle;
                        const radius = Math.sqrt(index / total) * 400;
                        return {
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle)
                        };
                    }

                    case 'wave-scatter': {
                        const waveCount = 4;
                        const waveX = (progress - 0.5) * 800;
                        const waveY = Math.sin(progress * Math.PI * waveCount) * 200;
                        const scatter = (Math.random() - 0.5) * 100;
                        return {
                            x: waveX + scatter,
                            y: waveY + (Math.random() - 0.5) * 80
                        };
                    }

                    case 'concentric-rings': {
                        const rings = 5;
                        const ring = Math.floor(progress * rings);
                        const inRing = (progress * rings) - ring;
                        const angle = inRing * Math.PI * 2;
                        const radius = 80 + ring * 70;
                        return {
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle)
                        };
                    }

                    case 'diagonal-streams': {
                        const streamCount = 6;
                        const stream = Math.floor(progress * streamCount);
                        const inStream = (progress * streamCount) - stream;
                        const streamAngle = (stream / streamCount) * Math.PI * 2;
                        const distance = inStream * 600;
                        return {
                            x: distance * Math.cos(streamAngle) - 300,
                            y: distance * Math.sin(streamAngle) - 300
                        };
                    }

                    case 'organic-cluster': {
                        // Multiple cluster centers
                        const clusterCount = 4;
                        const cluster = index % clusterCount;
                        const clusterAngle = (cluster / clusterCount) * Math.PI * 2;
                        const clusterRadius = 200;
                        const clusterX = clusterRadius * Math.cos(clusterAngle);
                        const clusterY = clusterRadius * Math.sin(clusterAngle);

                        // Random offset within cluster
                        const spread = 120;
                        const offsetAngle = Math.random() * Math.PI * 2;
                        const offsetDist = Math.random() * spread;

                        return {
                            x: clusterX + offsetDist * Math.cos(offsetAngle),
                            y: clusterY + offsetDist * Math.sin(offsetAngle)
                        };
                    }

                    default:
                        return { x: 0, y: 0 };
                }
            }

            // Calculate position influence (additive offset)
            calculatePositionInfluence(position, time) {
                const mode = this.positionInfluence.mode;
                const amplitude = this.positionInfluence.amplitude;
                const ampMode = this.positionInfluence.amplitudeMode;

                // Get normalized position for amplitude calculation
                const normPos = {
                    x: position.normalizedX !== undefined ? position.normalizedX : 0.5,
                    y: position.normalizedY !== undefined ? position.normalizedY : 0.5
                };

                // Calculate amplitude factor based on position
                const ampFactor = this.getAmplitudeFactor(normPos, this.canvas.width, ampMode);
                const effectiveAmplitude = (amplitude / 100) * 200 * ampFactor; // Scale to pixels

                let offsetX = 0;
                let offsetY = 0;

                switch(mode) {
                    case 'noise': {
                        const noiseX = this.positionInfluence.noise.x;
                        const noiseY = this.positionInfluence.noise.y;
                        const speed = this.positionInfluence.noise.speed;
                        const seed = this.positionInfluence.noise.seed;

                        const t = time * speed;
                        offsetX = this.smoothNoise(position.index, t, noiseX, seed) * effectiveAmplitude;
                        offsetY = this.smoothNoise(position.index + 1000, t, noiseY, seed + 1000) * effectiveAmplitude;
                        break;
                    }

                    case 'sin': {
                        const freqX = this.positionInfluence.sin.x;
                        const freqY = this.positionInfluence.sin.y;
                        const cycle = this.positionInfluence.sin.cycle;

                        const phaseOffset = position.index * 0.1;
                        offsetX = Math.sin(time * freqX + phaseOffset) * effectiveAmplitude;
                        offsetY = Math.cos(time * freqY + phaseOffset) * effectiveAmplitude;
                        break;
                    }

                    case 'doublesin': {
                        const freqX = this.positionInfluence.sin.x;
                        const freqY = this.positionInfluence.sin.y;

                        const phaseOffset = position.index * 0.1;
                        offsetX = (Math.sin(time * freqX + phaseOffset) + Math.sin(time * freqX * 2.3 + phaseOffset)) * effectiveAmplitude * 0.5;
                        offsetY = (Math.cos(time * freqY + phaseOffset) + Math.cos(time * freqY * 1.7 + phaseOffset)) * effectiveAmplitude * 0.5;
                        break;
                    }
                }

                return { x: offsetX, y: offsetY };
            }

            // Calculate scale influence (multiplicative factor)
            calculateScaleInfluence(position, time) {
                const mode = this.scaleInfluence.mode;
                const min = this.scaleInfluence.min;
                const max = this.scaleInfluence.max;
                const easing = this.scaleInfluence.easing;

                let scaleFactor = 1.0;

                switch(mode) {
                    case 'position': {
                        // Scale based on position in sequence
                        const progress = position.index / Math.max(this.basePositions.length - 1, 1);
                        const easedProgress = this.applyEasingFunction(progress, easing);
                        scaleFactor = min + (max - min) * easedProgress;
                        break;
                    }

                    case 'sin': {
                        const phaseOffset = position.index * 0.1;
                        const sinValue = (Math.sin(time + phaseOffset) + 1) * 0.5; // 0 to 1
                        scaleFactor = min + (max - min) * sinValue;
                        break;
                    }

                    case 'doublesin': {
                        const phaseOffset = position.index * 0.1;
                        const sin1 = Math.sin(time + phaseOffset);
                        const sin2 = Math.sin(time * 2.3 + phaseOffset);
                        const sinValue = ((sin1 + sin2) / 2 + 1) * 0.5; // 0 to 1
                        scaleFactor = min + (max - min) * sinValue;
                        break;
                    }

                    case 'noise': {
                        const seed = this.positionInfluence.noise.seed;
                        const speed = this.positionInfluence.noise.speed;
                        const t = time * speed;
                        const noiseValue = (this.smoothNoise(position.index, t, 0.5, seed + 5000) + 1) * 0.5; // 0 to 1
                        scaleFactor = min + (max - min) * noiseValue;
                        break;
                    }
                }

                return scaleFactor;
            }

            // Helper easing function
            applyEasingFunction(t, easing) {
                switch(easing) {
                    case 'linear': return t;
                    case 'ease-in': return t * t;
                    case 'ease-out': return 1 - (1 - t) * (1 - t);
                    case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    case 'exponential': return Math.pow(t, 2.5);
                    default: return t;
                }
            }

            applyAnimations(position, time) {
                let x = position.baseX;
                let y = position.baseY;
                let rotation = 0;
                let scale = 1;
                let opacity = 1;

                // Auto-scale stagger for large element counts
                const elementCount = this.basePositions.length;
                const staggerScale = elementCount > 50 ? Math.min(1, 20 / elementCount) : 1;
                const phaseOffset = position.index * this.animParams.stagger * staggerScale;

                // Oscillate effect
                if (this.effects.oscillate) {
                    x += Math.sin(time + phaseOffset) * this.animParams.phaseX;
                    y += Math.cos(time * 0.7 + phaseOffset) * this.animParams.phaseY;
                }

                // Rotate effect
                if (this.effects.rotate) {
                    rotation = Math.sin(time * 0.5 + phaseOffset) * (this.animParams.rotationAmount * Math.PI / 180);
                }

                // Breathe effect (scale)
                if (this.effects.breathe) {
                    scale = 1 + Math.sin(time * 2 + phaseOffset) * this.animParams.breatheAmount;
                }

                // Wave effect (additional wave motion)
                if (this.effects.wave) {
                    const waveY = Math.sin((position.baseX / 100) + time * this.animParams.waveFrequency) * 30;
                    y += waveY;
                }

                // COMPOSABLE POSITION INFLUENCE (works with any base distribution)
                if (this.positionInfluence.mode !== 'none') {
                    const influence = this.calculatePositionInfluence(position, time);
                    x += influence.x;
                    y += influence.y;
                }

                // COMPOSABLE SCALE INFLUENCE (works with any base scale)
                if (this.scaleInfluence.mode !== 'none') {
                    scale *= this.calculateScaleInfluence(position, time);
                }

                // Pattern-specific animations
                if (this.pattern === 'circle' || this.pattern === 'orbital') {
                    // Orbital motion
                    if (position.baseAngle !== undefined) {
                        const orbitSpeed = this.pattern === 'orbital' ? (0.3 * (position.orbit + 1)) : 0.2;
                        const currentAngle = position.baseAngle + time * orbitSpeed;
                        const radius = position.orbitRadius || this.patternParams.radius;

                        // Pulsing radius
                        const radiusPulse = radius + Math.sin(time * 2 + phaseOffset) * 20;

                        x = this.canvas.width / 2 + radiusPulse * Math.cos(currentAngle);
                        y = this.canvas.height / 2 + radiusPulse * Math.sin(currentAngle);

                        if (this.effects.rotate) {
                            rotation = currentAngle + Math.PI / 2;
                        }
                    }
                }

                // Spiral growth animation
                if (this.pattern === 'spiral') {
                    const growthPulse = Math.sin(time * 0.5) * 0.3;
                    const angle = position.baseAngle + time * 0.3;
                    const radius = this.patternParams.spiralGrowth * angle * (1 + growthPulse);

                    x = this.canvas.width / 2 + radius * Math.cos(angle);
                    y = this.canvas.height / 2 + radius * Math.sin(angle);
                    rotation = angle;
                }

                // Apply advanced mode variations
                if (this.advancedMode) {
                    // Size variation
                    if (this.advancedParams.sizeVariation > 0) {
                        const sizeModifier = 1 + (position.sizeVar - 0.5) * this.advancedParams.sizeVariation;
                        scale *= sizeModifier;
                    }

                    // Opacity variation
                    if (this.advancedParams.opacityVariation > 0) {
                        opacity = 1 - (position.opacityVar * this.advancedParams.opacityVariation);
                    }
                }

                return { x, y, rotation, scale, opacity };
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.basePositions.length === 0) return;

                // Set up font
                this.ctx.font = `${this.font.weight} ${this.font.size}px ${this.font.family}`;
                this.ctx.fillStyle = '#000000';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';

                // Render each element with animations
                this.basePositions.forEach(position => {
                    const animated = this.applyAnimations(position, this.time);

                    this.ctx.save();
                    this.ctx.translate(animated.x, animated.y);
                    this.ctx.rotate(animated.rotation);
                    this.ctx.scale(animated.scale, animated.scale);

                    // Use animated opacity or default variation
                    if (this.advancedMode && this.advancedParams.opacityVariation > 0) {
                        this.ctx.globalAlpha = animated.opacity;
                    } else {
                        const opacityVariation = 0.8 + Math.sin(this.time + position.index * 0.1) * 0.2;
                        this.ctx.globalAlpha = opacityVariation;
                    }

                    this.ctx.fillText(position.text, 0, 0);
                    this.ctx.restore();
                });
            }

            animate(currentTime) {
                // Initialize time on first frame
                if (!currentTime) currentTime = 0;
                if (!this.lastTime) this.lastTime = currentTime;

                this.deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                if (this.isPlaying) {
                    this.time += this.deltaTime * this.animationSpeed;
                }

                // Calculate FPS
                this.frameCount++;
                this.fpsTime += this.deltaTime;
                if (this.fpsTime >= 1) {
                    this.fps = Math.round(this.frameCount / this.fpsTime);
                    this.frameCount = 0;
                    this.fpsTime = 0;
                    document.getElementById('fpsValue').textContent = this.fps;
                }

                this.render();

                requestAnimationFrame((time) => this.animate(time));
            }

            play() {
                this.isPlaying = true;
            }

            pause() {
                this.isPlaying = false;
            }

            reset() {
                this.time = 0;
                this.render();
            }

            updateText(text) {
                this.text = text;
                this.calculateBasePositions();
            }

            updatePattern(pattern) {
                this.pattern = pattern;
                this.calculateBasePositions();
            }

            exportFrame() {
                this.canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `text-visual-${Date.now()}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                }, 'image/png', 1.0);
            }

            async startMP4Recording(duration, progressCallback) {
                try {
                    // Reset animation to start of loop
                    this.time = 0;
                    this.isPlaying = true;
                    this.isRecording = true;
                    this.recordingStartTime = performance.now();
                    this.recordingDuration = duration * 1000; // Convert to milliseconds
                    this.recordedChunks = [];
                    this.recordingProgressCallback = progressCallback;

                    // Create media stream from canvas at 60 FPS
                    const fps = 60;
                    const stream = this.canvas.captureStream(fps);

                    // Check for H.264 codec support
                    let mimeType = 'video/mp4;codecs=h264';

                    // Fallback codec detection
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        // Try alternative H.264 variations
                        const h264Variations = [
                            'video/mp4',
                            'video/webm;codecs=h264',
                            'video/mp4;codecs=avc1',
                            'video/mp4;codecs=avc1.42E01E'
                        ];

                        for (const variation of h264Variations) {
                            if (MediaRecorder.isTypeSupported(variation)) {
                                mimeType = variation;
                                break;
                            }
                        }
                    }

                    // Studio-grade quality settings
                    const options = {
                        mimeType: mimeType,
                        videoBitsPerSecond: 10000000 // 10 Mbps for high quality
                    };

                    this.mediaRecorder = new MediaRecorder(stream, options);

                    // Handle data available
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    // Handle recording stop
                    this.mediaRecorder.onstop = () => {
                        this.finishMP4Recording();
                    };

                    // Handle errors
                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        this.stopRecording();
                        alert('Recording failed: ' + event.error.message);
                    };

                    // Start recording
                    this.mediaRecorder.start();

                    // Progress tracking
                    const progressInterval = setInterval(() => {
                        if (this.isRecording) {
                            const elapsed = performance.now() - this.recordingStartTime;
                            const progress = Math.min(elapsed / this.recordingDuration, 1);
                            if (this.recordingProgressCallback) {
                                this.recordingProgressCallback(progress);
                            }
                        } else {
                            clearInterval(progressInterval);
                        }
                    }, 100);

                    // Stop recording after duration
                    setTimeout(() => {
                        this.stopRecording();
                        clearInterval(progressInterval);
                    }, this.recordingDuration);

                } catch (error) {
                    console.error('Failed to start MP4 recording:', error);
                    this.isRecording = false;
                    alert('Failed to start recording: ' + error.message);
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
                this.isRecording = false;
            }

            finishMP4Recording() {
                // Create blob from chunks
                const blob = new Blob(this.recordedChunks, {
                    type: 'video/mp4'
                });

                // Download file
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `text-visual-animated-${Date.now()}.mp4`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);

                // Clean up
                this.recordedChunks = [];
                this.recordingProgressCallback = null;
            }

            async startGIFRecording(duration, progressCallback) {
                try {
                    // Reset animation to start of loop
                    this.time = 0;
                    this.isPlaying = true;
                    this.isRecording = true;
                    this.recordingStartTime = performance.now();
                    this.recordingDuration = duration * 1000; // Convert to milliseconds
                    this.recordingProgressCallback = progressCallback;

                    // GIF settings for high quality
                    // Higher frame rate = smoother animation but larger file
                    // 30 FPS is a good balance for GIF
                    const fps = 30;
                    const frameDelay = 1000 / fps; // milliseconds per frame
                    const totalFrames = Math.ceil((duration * 1000) / frameDelay);

                    // Initialize GIF encoder with high quality settings
                    this.gifEncoder = new GIF({
                        workers: 4, // Use 4 web workers for faster encoding
                        quality: 1, // 1 = best quality, 30 = worst (lower is better)
                        width: this.canvas.width,
                        height: this.canvas.height,
                        workerScript: '../../shared/gif.worker.js',
                        repeat: 0, // 0 = loop forever
                        transparent: null // No transparency
                    });

                    // Handle GIF rendering finished
                    this.gifEncoder.on('finished', (blob) => {
                        this.finishGIFRecording(blob);
                    });

                    // Handle progress from encoder
                    this.gifEncoder.on('progress', (p) => {
                        // This is the encoding progress (happens after frame capture)
                        // We'll show capture progress during recording
                    });

                    // Capture frames at intervals
                    let framesCaptured = 0;
                    const captureInterval = setInterval(() => {
                        if (this.isRecording && framesCaptured < totalFrames) {
                            // Add current frame to GIF
                            this.gifEncoder.addFrame(this.ctx, {
                                copy: true,
                                delay: frameDelay
                            });

                            framesCaptured++;

                            // Update progress (0 to 0.8 during capture, 0.8 to 1.0 during encoding)
                            const captureProgress = (framesCaptured / totalFrames) * 0.8;
                            if (this.recordingProgressCallback) {
                                this.recordingProgressCallback(captureProgress);
                            }

                            // Stop after all frames captured
                            if (framesCaptured >= totalFrames) {
                                clearInterval(captureInterval);
                                this.isRecording = false;

                                // Update progress to show encoding phase
                                if (this.recordingProgressCallback) {
                                    this.recordingProgressCallback(0.8);
                                }

                                // Start rendering GIF (this may take a moment)
                                this.gifEncoder.render();
                            }
                        }
                    }, frameDelay);

                } catch (error) {
                    console.error('Failed to start GIF recording:', error);
                    this.isRecording = false;
                    alert('Failed to start GIF recording: ' + error.message);
                }
            }

            finishGIFRecording(blob) {
                // Download file
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `text-visual-animated-${Date.now()}.gif`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);

                // Final progress update
                if (this.recordingProgressCallback) {
                    this.recordingProgressCallback(1.0);
                }

                // Clean up
                this.gifEncoder = null;
                this.recordingProgressCallback = null;
            }
        }

        // Initialize the engine
        const canvas = document.getElementById('visualCanvas');
        const engine = new AnimatedTextEngine(canvas);

        // UI Controls
        const controls = {
            textInput: document.getElementById('textInput'),
            charCount: document.getElementById('charCount'),
            modeButtons: document.querySelectorAll('.toggle-btn[data-mode]'),
            fontSelect: document.getElementById('fontSelect'),
            fontSize: document.getElementById('fontSize'),
            fontWeight: document.getElementById('fontWeight'),
            patternSelect: document.getElementById('patternSelect'),
            playBtn: document.getElementById('playBtn'),
            playIcon: document.getElementById('playIcon'),
            resetBtn: document.getElementById('resetBtn'),
            exportBtn: document.getElementById('exportBtn'),
            animSpeed: document.getElementById('animSpeed'),

            // Animation parameters
            phaseX: document.getElementById('phaseX'),
            phaseY: document.getElementById('phaseY'),
            rotAmount: document.getElementById('rotAmount'),
            waveFreq: document.getElementById('waveFreq'),
            stagger: document.getElementById('stagger'),

            // Effects checkboxes
            effectOscillate: document.getElementById('effectOscillate'),
            effectRotate: document.getElementById('effectRotate'),
            effectBreathe: document.getElementById('effectBreathe'),
            effectWave: document.getElementById('effectWave'),

            // Advanced mode controls
            advancedMode: document.getElementById('advancedMode'),
            advancedControls: document.getElementById('advancedControls'),
            repetitions: document.getElementById('repetitions'),
            fragmentMode: document.getElementById('fragmentMode'),
            density: document.getElementById('density'),
            overlap: document.getElementById('overlap'),
            sizeVariation: document.getElementById('sizeVariation'),
            opacityVariation: document.getElementById('opacityVariation')
        };

        // Pattern parameter templates
        const patternParamTemplates = {
            grid: `
                <div class="control-group">
                    <label>Columns: <span id="colsValue">5</span></label>
                    <div class="slider-container">
                        <input type="range" id="gridCols" min="1" max="20" value="5">
                        <span class="slider-value">5</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Gap X: <span id="gapXValue">80</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="gapX" min="20" max="200" value="80">
                        <span class="slider-value">80</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Gap Y: <span id="gapYValue">80</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="gapY" min="20" max="200" value="80">
                        <span class="slider-value">80</span>
                    </div>
                </div>
            `,
            circle: `
                <div class="control-group">
                    <label>Radius: <span id="radiusValue">200</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="radius" min="50" max="400" value="200">
                        <span class="slider-value">200</span>
                    </div>
                </div>
            `,
            spiral: `
                <div class="control-group">
                    <label>Growth: <span id="spiralGrowthValue">15</span></label>
                    <div class="slider-container">
                        <input type="range" id="spiralGrowth" min="5" max="30" value="15">
                        <span class="slider-value">15</span>
                    </div>
                </div>
            `,
            wave: `
                <p style="font-size: 11px; opacity: 0.7; margin: 8px 0;">
                    Wave pattern uses animation parameters above
                </p>
            `,
            random: `
                <p style="font-size: 11px; opacity: 0.7; margin: 8px 0;">
                    Random pattern creates organic motion
                </p>
            `,
            orbital: `
                <p style="font-size: 11px; opacity: 0.7; margin: 8px 0;">
                    Elements orbit in multiple rings
                </p>
            `
        };

        // Strategy parameter templates
        const strategyParamTemplates = {
            'progressive-spacing': `
                <div class="control-group">
                    <label>Start Spacing: <span id="startSpacingValue">5</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="startSpacing" min="1" max="50" value="5">
                        <span class="slider-value">5</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>End Spacing: <span id="endSpacingValue">100</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="endSpacing" min="10" max="200" value="100">
                        <span class="slider-value">100</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Vertical Spacing: <span id="vertSpacingValue">30</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="vertSpacing" min="10" max="100" value="30">
                        <span class="slider-value">30</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Progression Curve</label>
                    <select id="progressionCurve">
                        <option value="linear">Linear</option>
                        <option value="ease-in">Ease In</option>
                        <option value="ease-out">Ease Out</option>
                        <option value="ease-in-out">Ease In-Out</option>
                        <option value="exponential">Exponential</option>
                    </select>
                </div>
            `,
            'path-following': `
                <div class="control-group">
                    <label>Path Type</label>
                    <select id="pathType">
                        <option value="circle">Circle</option>
                        <option value="spiral-arch">Spiral (Archimedean)</option>
                        <option value="spiral-log">Spiral (Logarithmic)</option>
                        <option value="wave-sine">Sine Wave</option>
                        <option value="lissajous">Lissajous Curve</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Path Count: <span id="pathCountValue">3</span></label>
                    <div class="slider-container">
                        <input type="range" id="pathCount" min="1" max="20" value="3">
                        <span class="slider-value">3</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Start Radius: <span id="startRadiusValue">100</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="startRadius" min="50" max="400" value="100">
                        <span class="slider-value">100</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>End Radius: <span id="endRadiusValue">300</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="endRadius" min="100" max="600" value="300">
                        <span class="slider-value">300</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="checkbox-container">
                        <input type="checkbox" id="tangentRotation" checked>
                        <label for="tangentRotation" class="checkbox-label">Rotate Along Path</label>
                    </div>
                </div>
            `,
            'word-extraction': `
                <div class="control-group">
                    <label>Distribution Pattern</label>
                    <select id="wordDistPattern">
                        <option value="radial-burst">Radial Burst</option>
                        <option value="wave-scatter">Wave Scatter</option>
                        <option value="concentric-rings">Concentric Rings</option>
                        <option value="diagonal-streams">Diagonal Streams</option>
                        <option value="organic-cluster">Organic Clusters</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Word Density: <span id="wordDensityValue">50</span></label>
                    <div class="slider-container">
                        <input type="range" id="wordDensity" min="10" max="200" value="50">
                        <span class="slider-value">50</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Rotation Spread: <span id="rotSpreadValue">45</span>°</label>
                    <div class="slider-container">
                        <input type="range" id="rotSpread" min="0" max="180" value="45">
                        <span class="slider-value">45</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Scale Min: <span id="scaleMinValue">0.5</span></label>
                    <div class="slider-container">
                        <input type="range" id="scaleMin" min="0.1" max="1" step="0.1" value="0.5">
                        <span class="slider-value">0.5</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Scale Max: <span id="scaleMaxValue">2.0</span></label>
                    <div class="slider-container">
                        <input type="range" id="scaleMax" min="1" max="3" step="0.1" value="2">
                        <span class="slider-value">2.0</span>
                    </div>
                </div>
            `,
            'none': ''
        };

        // Helper function to update slider displays
        function updateSliderDisplay(slider, displayElement, suffix = '') {
            displayElement.textContent = slider.value + suffix;
            if (slider.nextElementSibling && slider.nextElementSibling.classList.contains('slider-value')) {
                slider.nextElementSibling.textContent = slider.value;
            }
        }

        // Event Listeners

        // Text input
        controls.textInput.addEventListener('input', (e) => {
            engine.updateText(e.target.value);
            controls.charCount.textContent = e.target.value.length;
        });

        // Mode toggle
        controls.modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                controls.modeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                engine.mode = btn.dataset.mode;
                engine.calculateBasePositions();
            });
        });

        // Typography controls
        controls.fontSelect.addEventListener('change', (e) => {
            engine.font.family = e.target.value;
        });

        controls.fontSize.addEventListener('input', (e) => {
            engine.font.size = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('sizeValue'), 'px');
        });

        controls.fontWeight.addEventListener('input', (e) => {
            engine.font.weight = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('weightValue'));
        });

        // Pattern selection
        controls.patternSelect.addEventListener('change', (e) => {
            engine.updatePattern(e.target.value);
            document.getElementById('patternParams').innerHTML = patternParamTemplates[e.target.value] || '';
            attachPatternListeners(e.target.value);
        });

        // Animation controls
        controls.playBtn.addEventListener('click', () => {
            if (engine.isPlaying) {
                engine.pause();
                controls.playBtn.classList.remove('playing');
                controls.playIcon.textContent = '▶';
            } else {
                engine.play();
                controls.playBtn.classList.add('playing');
                controls.playIcon.textContent = '⏸';
            }
        });

        controls.resetBtn.addEventListener('click', () => {
            engine.reset();
        });

        controls.animSpeed.addEventListener('input', (e) => {
            engine.animationSpeed = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('speedValue'), 'x');
        });

        // Animation parameters
        controls.phaseX.addEventListener('input', (e) => {
            engine.animParams.phaseX = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('phaseXValue'), 'px');
        });

        controls.phaseY.addEventListener('input', (e) => {
            engine.animParams.phaseY = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('phaseYValue'), 'px');
        });

        controls.rotAmount.addEventListener('input', (e) => {
            engine.animParams.rotationAmount = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('rotAmountValue'), '°');
        });

        controls.waveFreq.addEventListener('input', (e) => {
            engine.animParams.waveFrequency = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('waveFreqValue'));
        });

        controls.stagger.addEventListener('input', (e) => {
            engine.animParams.stagger = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('staggerValue'));
        });

        // Effects toggles
        controls.effectOscillate.addEventListener('change', (e) => {
            engine.effects.oscillate = e.target.checked;
        });

        controls.effectRotate.addEventListener('change', (e) => {
            engine.effects.rotate = e.target.checked;
        });

        controls.effectBreathe.addEventListener('change', (e) => {
            engine.effects.breathe = e.target.checked;
        });

        controls.effectWave.addEventListener('change', (e) => {
            engine.effects.wave = e.target.checked;
        });

        // Export - Frame (existing)
        controls.exportBtn.addEventListener('click', () => {
            engine.exportFrame();
        });

        // Export - Type Toggle (Frame vs Animation)
        const exportTypeButtons = document.querySelectorAll('[data-export]');
        const frameExportControls = document.getElementById('frameExportControls');
        const animationExportControls = document.getElementById('animationExportControls');

        exportTypeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                exportTypeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const type = btn.dataset.export;
                frameExportControls.style.display = type === 'frame' ? 'block' : 'none';
                animationExportControls.style.display = type === 'animation' ? 'block' : 'none';

                if (type === 'animation') {
                    updateLoopDuration();
                }
            });
        });

        // Export - Format Toggle (MP4 vs GIF)
        const formatButtons = document.querySelectorAll('[data-format]');
        formatButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                formatButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Export - Duration Mode Toggle (Auto vs Custom)
        const durationModeButtons = document.querySelectorAll('[data-duration]');
        const customDurationControls = document.getElementById('customDurationControls');

        durationModeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                durationModeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const mode = btn.dataset.duration;
                customDurationControls.style.display = mode === 'custom' ? 'block' : 'none';
            });
        });

        // Update loop duration display
        function updateLoopDuration() {
            const duration = engine.calculateLoopDuration();
            document.getElementById('autoLoopDuration').textContent = duration.toFixed(2);
        }

        // Update loop duration when animation parameters change
        controls.animSpeed.addEventListener('input', updateLoopDuration);
        controls.effectOscillate.addEventListener('change', updateLoopDuration);
        controls.effectRotate.addEventListener('change', updateLoopDuration);
        controls.effectBreathe.addEventListener('change', updateLoopDuration);
        controls.effectWave.addEventListener('change', updateLoopDuration);
        controls.waveFreq.addEventListener('input', updateLoopDuration);
        controls.patternSelect.addEventListener('change', updateLoopDuration);

        // Custom duration slider
        const customDurationSlider = document.getElementById('customDuration');
        customDurationSlider.addEventListener('input', (e) => {
            updateSliderDisplay(e.target, document.getElementById('customDurationValue'), 's');
        });

        // Export Animation Button
        const exportAnimationBtn = document.getElementById('exportAnimationBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingProgress = document.getElementById('recordingProgress');

        exportAnimationBtn.addEventListener('click', async () => {
            // Get selected format
            const activeFormatBtn = document.querySelector('[data-format].active');
            const format = activeFormatBtn ? activeFormatBtn.dataset.format : 'mp4';

            // Get duration
            const activeDurationBtn = document.querySelector('[data-duration].active');
            const durationMode = activeDurationBtn ? activeDurationBtn.dataset.duration : 'auto';

            let duration;
            if (durationMode === 'auto') {
                duration = engine.calculateLoopDuration();
            } else {
                duration = parseFloat(customDurationSlider.value);
            }

            // Check browser support for MP4
            if (format === 'mp4') {
                const testTypes = [
                    'video/mp4;codecs=h264',
                    'video/mp4',
                    'video/webm;codecs=h264',
                    'video/mp4;codecs=avc1'
                ];

                let supported = false;
                for (const type of testTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        supported = true;
                        break;
                    }
                }

                if (!supported) {
                    alert('Sorry, your browser doesn\'t support MP4 recording. Please try GIF format instead.');
                    return;
                }
            }

            // Show recording indicator
            recordingIndicator.style.display = 'block';
            exportAnimationBtn.disabled = true;
            exportAnimationBtn.style.opacity = '0.5';

            try {
                // Start recording with progress callback
                if (format === 'mp4') {
                    await engine.startMP4Recording(duration, (progress) => {
                        recordingProgress.textContent = Math.round(progress * 100);
                    });
                } else if (format === 'gif') {
                    await engine.startGIFRecording(duration, (progress) => {
                        recordingProgress.textContent = Math.round(progress * 100);
                    });
                }
            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed: ' + error.message);
            } finally {
                // Hide recording indicator
                setTimeout(() => {
                    recordingIndicator.style.display = 'none';
                    exportAnimationBtn.disabled = false;
                    exportAnimationBtn.style.opacity = '1';
                    recordingProgress.textContent = '0';
                }, 500);
            }
        });

        // Advanced Mode Controls
        controls.advancedMode.addEventListener('change', (e) => {
            engine.advancedMode = e.target.checked;
            controls.advancedControls.style.display = e.target.checked ? 'block' : 'none';

            // Reset repetitions if disabling
            if (!e.target.checked) {
                engine.advancedParams.repetitions = 1;
                controls.repetitions.value = 1;
                updateSliderDisplay(controls.repetitions, document.getElementById('repetitionsValue'), 'x');
            }

            engine.calculateBasePositions();
        });

        controls.repetitions.addEventListener('input', (e) => {
            engine.advancedParams.repetitions = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('repetitionsValue'), 'x');
            engine.calculateBasePositions();
        });

        controls.fragmentMode.addEventListener('change', (e) => {
            engine.advancedParams.fragmentMode = e.target.value;
            engine.calculateBasePositions();
        });

        controls.density.addEventListener('input', (e) => {
            engine.advancedParams.density = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('densityValue'));
            engine.calculateBasePositions();
        });

        controls.overlap.addEventListener('input', (e) => {
            engine.advancedParams.overlap = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('overlapValue'));
            engine.calculateBasePositions();
        });

        controls.sizeVariation.addEventListener('input', (e) => {
            engine.advancedParams.sizeVariation = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('sizeVariationValue'));
        });

        controls.opacityVariation.addEventListener('input', (e) => {
            engine.advancedParams.opacityVariation = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('opacityVariationValue'));
        });

        // Organic Distribution Controls
        const organicEnabled = document.getElementById('organicEnabled');
        organicEnabled.addEventListener('change', (e) => {
            engine.organicParams.enabled = e.target.checked;
            document.getElementById('organicControls').style.display = e.target.checked ? 'block' : 'none';
            engine.calculateBasePositions();
        });

        const repetitionType = document.getElementById('repetitionType');
        repetitionType.addEventListener('change', (e) => {
            engine.organicParams.repetitionType = e.target.value;
            engine.calculateBasePositions();
        });

        const organicLayout = document.getElementById('organicLayout');
        organicLayout.addEventListener('change', (e) => {
            engine.organicParams.layout = e.target.value;
            engine.calculateBasePositions();
        });

        const interval = document.getElementById('interval');
        interval.addEventListener('input', (e) => {
            engine.organicParams.interval = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('intervalValue'), 'px');
            engine.calculateBasePositions();
        });

        const distributionOrder = document.getElementById('distributionOrder');
        distributionOrder.addEventListener('change', (e) => {
            engine.distribution.order = e.target.value;
            engine.calculateBasePositions();
        });

        // Position Influence Controls
        const positionMode = document.getElementById('positionMode');
        positionMode.addEventListener('change', (e) => {
            engine.positionInfluence.mode = e.target.value;
        });

        const posAmplitude = document.getElementById('posAmplitude');
        posAmplitude.addEventListener('input', (e) => {
            engine.positionInfluence.amplitude = parseInt(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('posAmplitudeValue'));
        });

        const amplitudeMode = document.getElementById('amplitudeMode');
        amplitudeMode.addEventListener('change', (e) => {
            engine.positionInfluence.amplitudeMode = e.target.value;
        });

        // Scale Influence Controls
        const scaleMode = document.getElementById('scaleMode');
        scaleMode.addEventListener('change', (e) => {
            engine.scaleInfluence.mode = e.target.value;
        });

        const scaleInfluenceMin = document.getElementById('scaleInfluenceMin');
        scaleInfluenceMin.addEventListener('input', (e) => {
            engine.scaleInfluence.min = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('scaleMinValue'));
        });

        const scaleInfluenceMax = document.getElementById('scaleInfluenceMax');
        scaleInfluenceMax.addEventListener('input', (e) => {
            engine.scaleInfluence.max = parseFloat(e.target.value);
            updateSliderDisplay(e.target, document.getElementById('scaleMaxValue'));
        });

        // Attach strategy-specific listeners
        function attachStrategyListeners(strategy) {
            switch(strategy) {
                case 'progressive-spacing':
                    const startSpacing = document.getElementById('startSpacing');
                    const endSpacing = document.getElementById('endSpacing');
                    const vertSpacing = document.getElementById('vertSpacing');
                    const progressionCurve = document.getElementById('progressionCurve');

                    if (startSpacing) {
                        startSpacing.addEventListener('input', (e) => {
                            engine.progressiveParams.startSpacing = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('startSpacingValue'), 'px');
                            engine.calculateBasePositions();
                        });
                    }
                    if (endSpacing) {
                        endSpacing.addEventListener('input', (e) => {
                            engine.progressiveParams.endSpacing = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('endSpacingValue'), 'px');
                            engine.calculateBasePositions();
                        });
                    }
                    if (vertSpacing) {
                        vertSpacing.addEventListener('input', (e) => {
                            engine.progressiveParams.verticalSpacing = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('vertSpacingValue'), 'px');
                            engine.calculateBasePositions();
                        });
                    }
                    if (progressionCurve) {
                        progressionCurve.addEventListener('change', (e) => {
                            engine.progressiveParams.easing = e.target.value;
                            engine.calculateBasePositions();
                        });
                    }
                    break;

                case 'path-following':
                    const pathType = document.getElementById('pathType');
                    const pathCount = document.getElementById('pathCount');
                    const startRadius = document.getElementById('startRadius');
                    const endRadius = document.getElementById('endRadius');
                    const tangentRotation = document.getElementById('tangentRotation');

                    if (pathType) {
                        pathType.addEventListener('change', (e) => {
                            engine.pathParams.type = e.target.value;
                            engine.calculateBasePositions();
                        });
                    }
                    if (pathCount) {
                        pathCount.addEventListener('input', (e) => {
                            engine.pathParams.count = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('pathCountValue'));
                            engine.calculateBasePositions();
                        });
                    }
                    if (startRadius) {
                        startRadius.addEventListener('input', (e) => {
                            engine.pathParams.startRadius = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('startRadiusValue'), 'px');
                            engine.calculateBasePositions();
                        });
                    }
                    if (endRadius) {
                        endRadius.addEventListener('input', (e) => {
                            engine.pathParams.endRadius = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('endRadiusValue'), 'px');
                            engine.calculateBasePositions();
                        });
                    }
                    if (tangentRotation) {
                        tangentRotation.addEventListener('change', (e) => {
                            engine.pathParams.tangentRotation = e.target.checked;
                            engine.calculateBasePositions();
                        });
                    }
                    break;

                case 'word-extraction':
                    const wordDistPattern = document.getElementById('wordDistPattern');
                    const wordDensity = document.getElementById('wordDensity');
                    const rotSpread = document.getElementById('rotSpread');
                    const scaleMin = document.getElementById('scaleMin');
                    const scaleMax = document.getElementById('scaleMax');

                    if (wordDistPattern) {
                        wordDistPattern.addEventListener('change', (e) => {
                            engine.wordExtractParams.pattern = e.target.value;
                            engine.calculateBasePositions();
                        });
                    }
                    if (wordDensity) {
                        wordDensity.addEventListener('input', (e) => {
                            engine.wordExtractParams.density = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('wordDensityValue'));
                            engine.calculateBasePositions();
                        });
                    }
                    if (rotSpread) {
                        rotSpread.addEventListener('input', (e) => {
                            engine.wordExtractParams.rotationSpread = parseInt(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('rotSpreadValue'), '°');
                            engine.calculateBasePositions();
                        });
                    }
                    if (scaleMin) {
                        scaleMin.addEventListener('input', (e) => {
                            engine.wordExtractParams.scaleMin = parseFloat(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('scaleMinValue'));
                            engine.calculateBasePositions();
                        });
                    }
                    if (scaleMax) {
                        scaleMax.addEventListener('input', (e) => {
                            engine.wordExtractParams.scaleMax = parseFloat(e.target.value);
                            updateSliderDisplay(e.target, document.getElementById('scaleMaxValue'));
                            engine.calculateBasePositions();
                        });
                    }
                    break;
            }
        }

        // Attach pattern-specific listeners
        function attachPatternListeners(pattern) {
            switch(pattern) {
                case 'grid':
                    const gridCols = document.getElementById('gridCols');
                    const gapX = document.getElementById('gapX');
                    const gapY = document.getElementById('gapY');

                    if (gridCols) {
                        gridCols.addEventListener('input', (e) => {
                            engine.patternParams.cols = parseInt(e.target.value);
                            engine.calculateBasePositions();
                            updateSliderDisplay(e.target, document.getElementById('colsValue'));
                        });
                    }
                    if (gapX) {
                        gapX.addEventListener('input', (e) => {
                            engine.patternParams.gapX = parseInt(e.target.value);
                            engine.calculateBasePositions();
                            updateSliderDisplay(e.target, document.getElementById('gapXValue'), 'px');
                        });
                    }
                    if (gapY) {
                        gapY.addEventListener('input', (e) => {
                            engine.patternParams.gapY = parseInt(e.target.value);
                            engine.calculateBasePositions();
                            updateSliderDisplay(e.target, document.getElementById('gapYValue'), 'px');
                        });
                    }
                    break;

                case 'circle':
                    const radius = document.getElementById('radius');
                    if (radius) {
                        radius.addEventListener('input', (e) => {
                            engine.patternParams.radius = parseInt(e.target.value);
                            engine.calculateBasePositions();
                            updateSliderDisplay(e.target, document.getElementById('radiusValue'), 'px');
                        });
                    }
                    break;

                case 'spiral':
                    const spiralGrowth = document.getElementById('spiralGrowth');
                    if (spiralGrowth) {
                        spiralGrowth.addEventListener('input', (e) => {
                            engine.patternParams.spiralGrowth = parseInt(e.target.value);
                            engine.calculateBasePositions();
                            updateSliderDisplay(e.target, document.getElementById('spiralGrowthValue'));
                        });
                    }
                    break;
            }
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            engine.setupCanvas();
        });

        // Initialize pattern parameters
        document.getElementById('patternParams').innerHTML = patternParamTemplates.grid;
        attachPatternListeners('grid');

        // Text Visualizer Preset Integration
        // Extract all current parameters
        function extractTextParams() {
            // Get active mode (words/characters)
            let activeMode = 'characters';
            document.querySelectorAll('[data-mode]').forEach(btn => {
                if (btn.classList.contains('active')) {
                    activeMode = btn.getAttribute('data-mode');
                }
            });

            return {
                // Text and mode
                textInput: document.getElementById('textInput').value,
                mode: activeMode,

                // Animation settings
                isPlaying: engine.isPlaying,
                animSpeed: parseFloat(document.getElementById('animSpeed').value),

                // Effects
                effectOscillate: document.getElementById('effectOscillate').checked,
                effectRotate: document.getElementById('effectRotate').checked,
                effectBreathe: document.getElementById('effectBreathe').checked,
                effectWave: document.getElementById('effectWave').checked,

                // Animation parameters
                phaseX: parseInt(document.getElementById('phaseX').value),
                phaseY: parseInt(document.getElementById('phaseY').value),
                rotAmount: parseInt(document.getElementById('rotAmount').value),
                waveFreq: parseFloat(document.getElementById('waveFreq').value),
                stagger: parseFloat(document.getElementById('stagger').value),

                // Advanced mode
                advancedMode: document.getElementById('advancedMode').checked,
                repetitions: parseInt(document.getElementById('repetitions').value),
                fragmentMode: document.getElementById('fragmentMode').value,
                density: parseFloat(document.getElementById('density').value),
                overlap: parseFloat(document.getElementById('overlap').value),
                sizeVariation: parseFloat(document.getElementById('sizeVariation').value),
                opacityVariation: parseFloat(document.getElementById('opacityVariation').value),

                // Organic Distribution System
                organicEnabled: document.getElementById('organicEnabled')?.checked || false,
                repetitionType: document.getElementById('repetitionType')?.value || 'phrase',
                organicLayout: document.getElementById('organicLayout')?.value || 'vertical',
                interval: parseInt(document.getElementById('interval')?.value || 10),
                distributionOrder: document.getElementById('distributionOrder')?.value || 'sequential',

                // Position Influence
                positionMode: document.getElementById('positionMode')?.value || 'none',
                posAmplitude: parseInt(document.getElementById('posAmplitude')?.value || 50),
                amplitudeMode: document.getElementById('amplitudeMode')?.value || 'uniform',

                // Scale Influence
                scaleMode: document.getElementById('scaleMode')?.value || 'none',
                scaleInfluenceMin: parseFloat(document.getElementById('scaleInfluenceMin')?.value || 0.2),
                scaleInfluenceMax: parseFloat(document.getElementById('scaleInfluenceMax')?.value || 1.0),

                // Typography
                fontFamily: document.getElementById('fontSelect').value,
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontWeight: parseInt(document.getElementById('fontWeight').value),

                // Pattern
                pattern: document.getElementById('patternSelect').value,

                // Pattern-specific parameters
                patternCols: parseInt(document.getElementById('patternCols')?.value || 5),
                patternGapX: parseInt(document.getElementById('patternGapX')?.value || 80),
                patternGapY: parseInt(document.getElementById('patternGapY')?.value || 80),
                patternRadius: parseInt(document.getElementById('patternRadius')?.value || 200),
                patternGrowth: parseInt(document.getElementById('patternGrowth')?.value || 15),

                // Export settings
                exportType: document.querySelector('[data-export].active')?.dataset.export || 'frame',
                exportFormat: document.querySelector('[data-format].active')?.dataset.format || 'mp4',
                durationMode: document.querySelector('[data-duration].active')?.dataset.duration || 'auto',
                customDuration: parseInt(document.getElementById('customDuration')?.value || 5)
            };
        }

        // Apply preset parameters
        function applyTextPreset(params) {
            // Text and mode
            if (params.textInput !== undefined) {
                document.getElementById('textInput').value = params.textInput;
                document.getElementById('charCount').textContent = params.textInput.length;
                engine.text = params.textInput;
            }

            if (params.mode !== undefined) {
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    btn.classList.toggle('active', btn.getAttribute('data-mode') === params.mode);
                });
                engine.mode = params.mode;
            }

            // Animation settings
            if (params.isPlaying !== undefined) {
                engine.isPlaying = params.isPlaying;
                const playBtn = document.getElementById('playBtn');
                playBtn.classList.toggle('playing', params.isPlaying);
                document.getElementById('playIcon').textContent = params.isPlaying ? '⏸' : '▶';
            }

            if (params.animSpeed !== undefined) {
                document.getElementById('animSpeed').value = params.animSpeed;
                document.getElementById('speedValue').textContent = params.animSpeed.toFixed(1);
                document.querySelector('#animSpeed + .slider-value').textContent = params.animSpeed.toFixed(1);
                engine.animationSpeed = params.animSpeed;
            }

            // Effects
            if (params.effectOscillate !== undefined) {
                document.getElementById('effectOscillate').checked = params.effectOscillate;
                engine.effects.oscillate = params.effectOscillate;
            }
            if (params.effectRotate !== undefined) {
                document.getElementById('effectRotate').checked = params.effectRotate;
                engine.effects.rotate = params.effectRotate;
            }
            if (params.effectBreathe !== undefined) {
                document.getElementById('effectBreathe').checked = params.effectBreathe;
                engine.effects.breathe = params.effectBreathe;
            }
            if (params.effectWave !== undefined) {
                document.getElementById('effectWave').checked = params.effectWave;
                engine.effects.wave = params.effectWave;
            }

            // Animation parameters
            if (params.phaseX !== undefined) {
                document.getElementById('phaseX').value = params.phaseX;
                document.getElementById('phaseXValue').textContent = params.phaseX;
                document.querySelector('#phaseX + .slider-value').textContent = params.phaseX;
                engine.animParams.phaseX = params.phaseX;
            }
            if (params.phaseY !== undefined) {
                document.getElementById('phaseY').value = params.phaseY;
                document.getElementById('phaseYValue').textContent = params.phaseY;
                document.querySelector('#phaseY + .slider-value').textContent = params.phaseY;
                engine.animParams.phaseY = params.phaseY;
            }
            if (params.rotAmount !== undefined) {
                document.getElementById('rotAmount').value = params.rotAmount;
                document.getElementById('rotAmountValue').textContent = params.rotAmount;
                document.querySelector('#rotAmount + .slider-value').textContent = params.rotAmount;
                engine.animParams.rotationAmount = params.rotAmount;
            }
            if (params.waveFreq !== undefined) {
                document.getElementById('waveFreq').value = params.waveFreq;
                document.getElementById('waveFreqValue').textContent = params.waveFreq;
                document.querySelector('#waveFreq + .slider-value').textContent = params.waveFreq;
                engine.animParams.waveFrequency = params.waveFreq;
            }
            if (params.stagger !== undefined) {
                document.getElementById('stagger').value = params.stagger;
                document.getElementById('staggerValue').textContent = params.stagger;
                document.querySelector('#stagger + .slider-value').textContent = params.stagger;
                engine.animParams.stagger = params.stagger;
            }

            // Advanced mode
            if (params.advancedMode !== undefined) {
                document.getElementById('advancedMode').checked = params.advancedMode;
                document.getElementById('advancedControls').style.display = params.advancedMode ? 'block' : 'none';
                engine.advancedMode = params.advancedMode;
            }

            if (params.repetitions !== undefined) {
                document.getElementById('repetitions').value = params.repetitions;
                document.getElementById('repetitionsValue').textContent = params.repetitions;
                document.querySelector('#repetitions + .slider-value').textContent = params.repetitions;
                engine.advancedParams.repetitions = params.repetitions;
            }
            if (params.fragmentMode !== undefined) {
                document.getElementById('fragmentMode').value = params.fragmentMode;
                engine.advancedParams.fragmentMode = params.fragmentMode;
            }
            if (params.density !== undefined) {
                document.getElementById('density').value = params.density;
                document.getElementById('densityValue').textContent = params.density.toFixed(1);
                document.querySelector('#density + .slider-value').textContent = params.density.toFixed(1);
                engine.advancedParams.density = params.density;
            }
            if (params.overlap !== undefined) {
                document.getElementById('overlap').value = params.overlap;
                document.getElementById('overlapValue').textContent = params.overlap;
                document.querySelector('#overlap + .slider-value').textContent = params.overlap;
                engine.advancedParams.overlap = params.overlap;
            }
            if (params.sizeVariation !== undefined) {
                document.getElementById('sizeVariation').value = params.sizeVariation;
                document.getElementById('sizeVariationValue').textContent = params.sizeVariation;
                document.querySelector('#sizeVariation + .slider-value').textContent = params.sizeVariation;
                engine.advancedParams.sizeVariation = params.sizeVariation;
            }
            if (params.opacityVariation !== undefined) {
                document.getElementById('opacityVariation').value = params.opacityVariation;
                document.getElementById('opacityVariationValue').textContent = params.opacityVariation;
                document.querySelector('#opacityVariation + .slider-value').textContent = params.opacityVariation;
                engine.advancedParams.opacityVariation = params.opacityVariation;
            }

            // Organic Distribution System
            if (params.organicEnabled !== undefined) {
                document.getElementById('organicEnabled').checked = params.organicEnabled;
                engine.organicParams.enabled = params.organicEnabled;
                document.getElementById('organicControls').style.display = params.organicEnabled ? 'block' : 'none';
            }
            if (params.repetitionType !== undefined) {
                document.getElementById('repetitionType').value = params.repetitionType;
                engine.organicParams.repetitionType = params.repetitionType;
            }
            if (params.organicLayout !== undefined) {
                document.getElementById('organicLayout').value = params.organicLayout;
                engine.organicParams.layout = params.organicLayout;
            }
            if (params.interval !== undefined) {
                document.getElementById('interval').value = params.interval;
                document.getElementById('intervalValue').textContent = params.interval;
                document.querySelector('#interval + .slider-value').textContent = params.interval;
                engine.organicParams.interval = params.interval;
            }
            if (params.distributionOrder !== undefined) {
                document.getElementById('distributionOrder').value = params.distributionOrder;
                engine.distribution.order = params.distributionOrder;
            }

            // Position Influence
            if (params.positionMode !== undefined) {
                document.getElementById('positionMode').value = params.positionMode;
                engine.positionInfluence.mode = params.positionMode;
            }
            if (params.posAmplitude !== undefined) {
                document.getElementById('posAmplitude').value = params.posAmplitude;
                document.getElementById('posAmplitudeValue').textContent = params.posAmplitude;
                document.querySelector('#posAmplitude + .slider-value').textContent = params.posAmplitude;
                engine.positionInfluence.amplitude = params.posAmplitude;
            }
            if (params.amplitudeMode !== undefined) {
                document.getElementById('amplitudeMode').value = params.amplitudeMode;
                engine.positionInfluence.amplitudeMode = params.amplitudeMode;
            }

            // Scale Influence
            if (params.scaleMode !== undefined) {
                document.getElementById('scaleMode').value = params.scaleMode;
                engine.scaleInfluence.mode = params.scaleMode;
            }
            if (params.scaleInfluenceMin !== undefined) {
                document.getElementById('scaleInfluenceMin').value = params.scaleInfluenceMin;
                document.getElementById('scaleMinValue').textContent = params.scaleInfluenceMin;
                document.querySelector('#scaleInfluenceMin + .slider-value').textContent = params.scaleInfluenceMin;
                engine.scaleInfluence.min = params.scaleInfluenceMin;
            }
            if (params.scaleInfluenceMax !== undefined) {
                document.getElementById('scaleInfluenceMax').value = params.scaleInfluenceMax;
                document.getElementById('scaleMaxValue').textContent = params.scaleInfluenceMax;
                document.querySelector('#scaleInfluenceMax + .slider-value').textContent = params.scaleInfluenceMax;
                engine.scaleInfluence.max = params.scaleInfluenceMax;
            }

            // Typography
            if (params.fontFamily !== undefined) {
                document.getElementById('fontSelect').value = params.fontFamily;
                engine.font.family = params.fontFamily;
            }
            if (params.fontSize !== undefined) {
                document.getElementById('fontSize').value = params.fontSize;
                document.getElementById('sizeValue').textContent = params.fontSize;
                document.querySelector('#fontSize + .slider-value').textContent = params.fontSize;
                engine.font.size = params.fontSize;
            }
            if (params.fontWeight !== undefined) {
                document.getElementById('fontWeight').value = params.fontWeight;
                document.getElementById('weightValue').textContent = params.fontWeight;
                document.querySelector('#fontWeight + .slider-value').textContent = params.fontWeight;
                engine.font.weight = params.fontWeight;
            }

            // Pattern
            if (params.pattern !== undefined) {
                document.getElementById('patternSelect').value = params.pattern;
                engine.pattern = params.pattern;
                // Update pattern UI
                document.getElementById('patternParams').innerHTML = patternParamTemplates[params.pattern] || '';
                attachPatternListeners(params.pattern);
            }

            // Pattern-specific parameters
            if (params.patternCols !== undefined && document.getElementById('patternCols')) {
                document.getElementById('patternCols').value = params.patternCols;
                engine.patternParams.cols = params.patternCols;
            }
            if (params.patternGapX !== undefined && document.getElementById('patternGapX')) {
                document.getElementById('patternGapX').value = params.patternGapX;
                engine.patternParams.gapX = params.patternGapX;
            }
            if (params.patternGapY !== undefined && document.getElementById('patternGapY')) {
                document.getElementById('patternGapY').value = params.patternGapY;
                engine.patternParams.gapY = params.patternGapY;
            }
            if (params.patternRadius !== undefined && document.getElementById('patternRadius')) {
                document.getElementById('patternRadius').value = params.patternRadius;
                engine.patternParams.radius = params.patternRadius;
            }
            if (params.patternGrowth !== undefined && document.getElementById('patternGrowth')) {
                document.getElementById('patternGrowth').value = params.patternGrowth;
                engine.patternParams.spiralGrowth = params.patternGrowth;
            }

            // Export settings
            if (params.exportType !== undefined) {
                document.querySelectorAll('[data-export]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.export === params.exportType);
                });
                // Show/hide appropriate controls
                const frameExportControls = document.getElementById('frameExportControls');
                const animationExportControls = document.getElementById('animationExportControls');
                frameExportControls.style.display = params.exportType === 'frame' ? 'block' : 'none';
                animationExportControls.style.display = params.exportType === 'animation' ? 'block' : 'none';
            }

            if (params.exportFormat !== undefined) {
                document.querySelectorAll('[data-format]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.format === params.exportFormat);
                });
            }

            if (params.durationMode !== undefined) {
                document.querySelectorAll('[data-duration]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.duration === params.durationMode);
                });
                const customDurationControls = document.getElementById('customDurationControls');
                customDurationControls.style.display = params.durationMode === 'custom' ? 'block' : 'none';
            }

            if (params.customDuration !== undefined) {
                const customDurationSlider = document.getElementById('customDuration');
                if (customDurationSlider) {
                    customDurationSlider.value = params.customDuration;
                    document.getElementById('customDurationValue').textContent = params.customDuration;
                    const sliderValue = customDurationSlider.nextElementSibling;
                    if (sliderValue && sliderValue.classList.contains('slider-value')) {
                        sliderValue.textContent = params.customDuration;
                    }
                }
            }

            // Recalculate positions after applying preset
            engine.calculateBasePositions();
        }

        // Make functions global for module access
        window.extractTextParams = extractTextParams;
        window.applyTextPreset = applyTextPreset;
    </script>

    <!-- Preset System Scripts -->
    <script type="module">
        import { PresetManager } from '../../shared/preset-manager.js';
        import { PresetUIComponent } from '../../shared/preset-ui-component.js';

        // Initialize preset manager for Text Visualizer
        const presetManager = new PresetManager('text-visualizer');
        const presetUI = new PresetUIComponent(presetManager, window.extractTextParams);

        // Wait for a short delay to ensure engine is initialized
        setTimeout(async () => {
            // Create preset UI
            presetUI.create('presetContainer');

            // Initialize with random preset
            await presetManager.initialize(window.applyTextPreset);
        }, 100);

        // Make preset manager available globally for debugging
        window.textPresetManager = presetManager;
    </script>
</body>
</html>